[
  {
    "id": "two-sum",
    "title": {
      "en": "Two Sum",
      "zh": "两数之和"
    },
    "difficulty": "Easy",
    "tags": [
      "array",
      "hash-table"
    ],
    "description": {
      "en": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
      "zh": "给定一个整数数组 nums 和一个整数目标值 target，请你在数组中找出和为目标值的那两个整数，并返回它们的数组下标。"
    },
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]"
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]"
      }
    ],
    "template": {
      "js": "function twoSum(nums, target) {\n  // write your code here\n}\nmodule.exports = twoSum;",
      "python": "def two_sum(nums, target):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // write your code here\n        return new int[0];\n    }\n}",
      "cpp": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // write your code here\n        return {};\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    // write your code here\n    *returnSize = 2;\n    int* result = (int*)malloc(2 * sizeof(int));\n    return result;\n}"
    },
    "solution": {
      "js": "function twoSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) return [map.get(complement), i];\n    map.set(nums[i], i);\n  }\n}\nmodule.exports = twoSum;"
    },
    "solutions": [
      {
        "title": {
          "en": "Hash Map Approach",
          "zh": "哈希表方法"
        },
        "content": {
          "en": "# Hash Map Approach\n\n## Algorithm Overview\n\nThe hash map approach is the most efficient solution for the Two Sum problem. It uses a hash map to store previously seen numbers and their indices, allowing us to find the complement in O(1) time.\n\n## Time Complexity\n- **Time**: O(n) - We traverse the array only once\n- **Space**: O(n) - Hash map can store up to n elements\n\n## Implementation\n\n```javascript\nfunction twoSum(nums, target) {\n  const map = new Map();\n  \n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    \n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    \n    map.set(nums[i], i);\n  }\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Initialize** a hash map to store numbers and their indices\n2. **Iterate** through the array\n3. **Calculate** the complement (target - current number)\n4. **Check** if complement exists in hash map\n5. **Return** indices if found, otherwise store current number\n\n## Example Walkthrough\n\nFor `nums = [2,7,11,15]`, `target = 9`:\n\n- i=0: complement = 9-2 = 7, not in map, store {2: 0}\n- i=1: complement = 9-7 = 2, found in map at index 0, return [0,1]\n\n## Why This Works\n\nThe key insight is that for each number, we only need to check if its complement has been seen before. By storing numbers as we go, we can find the solution in a single pass.",
          "zh": "# 哈希表方法\n\n## 算法概述\n\n哈希表方法是两数之和问题最高效的解决方案。它使用哈希表存储之前见过的数字及其索引，使我们能够在 O(1) 时间内找到补数。\n\n## 时间复杂度\n- **时间复杂度**: O(n) - 我们只遍历数组一次\n- **空间复杂度**: O(n) - 哈希表最多存储 n 个元素\n\n## 实现代码\n\n```javascript\nfunction twoSum(nums, target) {\n  const map = new Map();\n  \n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    \n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    \n    map.set(nums[i], i);\n  }\n}\n```\n\n## 逐步解释\n\n1. **初始化** 哈希表来存储数字和它们的索引\n2. **遍历** 数组\n3. **计算** 补数（目标值 - 当前数字）\n4. **检查** 补数是否存在于哈希表中\n5. **返回** 如果找到则返回索引，否则存储当前数字\n\n## 示例演示\n\n对于 `nums = [2,7,11,15]`，`target = 9`：\n\n- i=0: 补数 = 9-2 = 7，不在映射中，存储 {2: 0}\n- i=1: 补数 = 9-7 = 2，在映射中找到索引0，返回 [0,1]\n\n## 原理说明\n\n关键洞察是对于每个数字，我们只需要检查它的补数之前是否出现过。通过边遍历边存储数字，我们可以在单次遍历中找到解决方案。"
        }
      },
      {
        "title": {
          "en": "Brute Force Approach",
          "zh": "暴力搜索方法"
        },
        "content": {
          "en": "# Brute Force Approach\n\n## Algorithm Overview\n\nThe brute force approach checks every possible pair of numbers in the array to see if they sum to the target. While not the most efficient, it's straightforward and easy to understand.\n\n## Time Complexity\n- **Time**: O(n²) - Nested loop checks all pairs\n- **Space**: O(1) - Only uses constant extra space\n\n## Implementation\n\n```javascript\nfunction twoSum(nums, target) {\n  for (let i = 0; i < nums.length - 1; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Outer loop**: Iterate through each element (except the last)\n2. **Inner loop**: Check all elements after the current one\n3. **Check sum**: If the sum equals target, return indices\n4. **Continue**: If no match, try next pair\n\n## Example Walkthrough\n\nFor `nums = [2,7,11,15]`, `target = 9`:\n\n- i=0, j=1: nums[0] + nums[1] = 2 + 7 = 9 = target ✓\n- Return [0, 1]\n\n## Pros and Cons\n\n**Pros:**\n- Simple to understand and implement\n- No extra space needed\n- Works for unsorted arrays\n\n**Cons:**\n- O(n²) time complexity is inefficient for large arrays\n- Not optimal for performance-critical applications\n\n## When to Use\n\nThis approach is suitable for:\n- Small datasets\n- Learning/educational purposes\n- When memory is extremely limited",
          "zh": "# 暴力搜索方法\n\n## 算法概述\n\n暴力搜索方法检查数组中每一对可能的数字，看它们是否加起来等于目标值。虽然不是最高效的，但它直接易懂。\n\n## 时间复杂度\n- **时间复杂度**: O(n²) - 嵌套循环检查所有配对\n- **空间复杂度**: O(1) - 只使用常数额外空间\n\n## 实现代码\n\n```javascript\nfunction twoSum(nums, target) {\n  for (let i = 0; i < nums.length - 1; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n}\n```\n\n## 逐步解释\n\n1. **外层循环**: 遍历每个元素（除了最后一个）\n2. **内层循环**: 检查当前元素后的所有元素\n3. **检查和**: 如果和等于目标值，返回索引\n4. **继续**: 如果没有匹配，尝试下一对\n\n## 示例演示\n\n对于 `nums = [2,7,11,15]`，`target = 9`：\n\n- i=0, j=1: nums[0] + nums[1] = 2 + 7 = 9 = target ✓\n- 返回 [0, 1]\n\n## 优缺点\n\n**优点:**\n- 简单易懂和实现\n- 不需要额外空间\n- 适用于未排序数组\n\n**缺点:**\n- O(n²) 时间复杂度对大数组不高效\n- 不适合性能要求高的应用\n\n## 使用场景\n\n这种方法适用于：\n- 小数据集\n- 学习/教育目的\n- 内存极其有限的情况"
        }
      },
      {
        "title": {
          "en": "Two Pointers (Sorted)",
          "zh": "双指针方法（已排序）"
        },
        "content": {
          "en": "# Two Pointers Approach (Sorted Array)\n\n## Algorithm Overview\n\nThe two pointers approach works when the array is sorted. We use two pointers at the beginning and end of the array, moving them based on the sum comparison with the target.\n\n**Note**: This approach requires modification for the original Two Sum problem since we need to return original indices, not sorted indices.\n\n## Time Complexity\n- **Time**: O(n log n) - Due to sorting step\n- **Space**: O(n) - For storing original indices\n\n## Implementation\n\n```javascript\nfunction twoSum(nums, target) {\n  // Create array with values and original indices\n  const indexed = nums.map((num, i) => ({ num, index: i }));\n  \n  // Sort by number value\n  indexed.sort((a, b) => a.num - b.num);\n  \n  let left = 0;\n  let right = indexed.length - 1;\n  \n  while (left < right) {\n    const sum = indexed[left].num + indexed[right].num;\n    \n    if (sum === target) {\n      return [indexed[left].index, indexed[right].index];\n    } else if (sum < target) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Prepare**: Create indexed array and sort by values\n2. **Initialize**: Set left pointer at start, right at end\n3. **Compare**: Calculate sum of elements at pointers\n4. **Move pointers**: \n   - If sum < target: move left pointer right\n   - If sum > target: move right pointer left\n   - If sum = target: return original indices\n\n## Example Walkthrough\n\nFor `nums = [2,7,11,15]`, `target = 9`:\n\n1. indexed = [{num:2, index:0}, {num:7, index:1}, {num:11, index:2}, {num:15, index:3}]\n2. After sort: same (already sorted)\n3. left=0, right=3: sum = 2+15 = 17 > 9, right--\n4. left=0, right=2: sum = 2+11 = 13 > 9, right--\n5. left=0, right=1: sum = 2+7 = 9 = 9 ✓\n6. Return [0, 1]\n\n## When to Use\n\n- When array is already sorted\n- For educational purposes to understand two pointers technique\n- When you need to solve multiple Two Sum queries on the same array",
          "zh": "# 双指针方法（已排序数组）\n\n## 算法概述\n\n双指针方法适用于已排序的数组。我们在数组的开头和结尾使用两个指针，根据和与目标值的比较来移动它们。\n\n**注意**: 这种方法需要对原始两数之和问题进行修改，因为我们需要返回原始索引，而不是排序后的索引。\n\n## 时间复杂度\n- **时间复杂度**: O(n log n) - 由于排序步骤\n- **空间复杂度**: O(n) - 用于存储原始索引\n\n## 实现代码\n\n```javascript\nfunction twoSum(nums, target) {\n  // 创建包含值和原始索引的数组\n  const indexed = nums.map((num, i) => ({ num, index: i }));\n  \n  // 按数字值排序\n  indexed.sort((a, b) => a.num - b.num);\n  \n  let left = 0;\n  let right = indexed.length - 1;\n  \n  while (left < right) {\n    const sum = indexed[left].num + indexed[right].num;\n    \n    if (sum === target) {\n      return [indexed[left].index, indexed[right].index];\n    } else if (sum < target) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n}\n```\n\n## 逐步解释\n\n1. **准备**: 创建索引数组并按值排序\n2. **初始化**: 在开始处设置左指针，在结尾处设置右指针\n3. **比较**: 计算指针处元素的和\n4. **移动指针**: \n   - 如果和 < 目标值：向右移动左指针\n   - 如果和 > 目标值：向左移动右指针\n   - 如果和 = 目标值：返回原始索引\n\n## 示例演示\n\n对于 `nums = [2,7,11,15]`，`target = 9`：\n\n1. indexed = [{num:2, index:0}, {num:7, index:1}, {num:11, index:2}, {num:15, index:3}]\n2. 排序后: 相同（已经排序）\n3. left=0, right=3: sum = 2+15 = 17 > 9, right--\n4. left=0, right=2: sum = 2+11 = 13 > 9, right--\n5. left=0, right=1: sum = 2+7 = 9 = 9 ✓\n6. 返回 [0, 1]\n\n## 使用场景\n\n- 当数组已经排序时\n- 用于教育目的理解双指针技术\n- 当需要在同一数组上解决多个两数之和查询时"
        }
      }
    ],
    "tests": [
      {
        "input": "[2,7,11,15],9",
        "output": "[0,1]"
      },
      {
        "input": "[3,2,4],6",
        "output": "[1,2]"
      },
      {
        "input": "[3,3],6",
        "output": "[0,1]"
      },
      {
        "input": "[1,2,3,4,5],8",
        "output": "[2,4]"
      },
      {
        "input": "[0,4,3,0],0",
        "output": "[0,3]"
      },
      {
        "input": "[-1,-2,-3,-4,-5],-8",
        "output": "[2,4]"
      }
    ]
  },
  {
    "id": "reverse-integer",
    "title": {
      "en": "Reverse Integer",
      "zh": "整数反转"
    },
    "difficulty": "Medium",
    "tags": [
      "math"
    ],
    "description": {
      "en": "Given a signed 32-bit integer x, return x with its digits reversed.",
      "zh": "给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。"
    },
    "examples": [
      {
        "input": "x = 123",
        "output": "321"
      },
      {
        "input": "x = -123",
        "output": "-321"
      },
      {
        "input": "x = 120",
        "output": "21"
      }
    ],
    "template": {
      "js": "function reverse(x) {\n  // write your code here\n}\nmodule.exports = reverse;",
      "python": "def reverse(x):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int reverse(int x) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <climits>\nusing namespace std;\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n#include <limits.h>\n\nint reverse(int x) {\n    // write your code here\n    return 0;\n}"
    },
    "solution": {
      "js": "function reverse(x) {\n  const sign = x < 0 ? -1 : 1;\n  const reversed = parseInt(Math.abs(x).toString().split('').reverse().join(''));\n  if (reversed > 2**31 - 1) return 0;\n  return sign * reversed;\n}\nmodule.exports = reverse;"
    },
    "solutions": [
      {
        "title": {
          "en": "String Conversion Approach",
          "zh": "字符串转换方法"
        },
        "content": {
          "en": "# String Conversion Approach\n\n## Algorithm Overview\n\nThis approach converts the integer to a string, reverses the string, then converts back to integer. It's intuitive and handles the sign and overflow cases.\n\n## Time Complexity\n- **Time**: O(log n) - where n is the input number (number of digits)\n- **Space**: O(log n) - for string storage\n\n## Implementation\n\n```javascript\nfunction reverse(x) {\n  const sign = x < 0 ? -1 : 1;\n  const reversed = parseInt(Math.abs(x).toString().split('').reverse().join(''));\n  \n  // Check for 32-bit integer overflow\n  if (reversed > 2**31 - 1) return 0;\n  \n  return sign * reversed;\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Extract sign**: Store whether number is positive or negative\n2. **Convert to string**: Use `Math.abs(x).toString()` to get digits as string\n3. **Reverse string**: Split, reverse array, and join back\n4. **Convert back**: Use `parseInt()` to get integer\n5. **Check overflow**: Return 0 if result exceeds 32-bit integer range\n6. **Apply sign**: Multiply by stored sign\n\n## Example Walkthrough\n\nFor `x = -123`:\n\n1. sign = -1, abs = 123\n2. toString() = '123'\n3. split('') = ['1', '2', '3']\n4. reverse() = ['3', '2', '1']\n5. join('') = '321'\n6. parseInt('321') = 321\n7. 321 <= 2³¹-1, so no overflow\n8. Return -1 * 321 = -321\n\n## Pros and Cons\n\n**Pros:**\n- Easy to understand and implement\n- Handles negative numbers naturally\n- Clear overflow checking\n\n**Cons:**\n- String operations can be slower\n- Uses extra space for string conversion",
          "zh": "# 字符串转换方法\n\n## 算法概述\n\n这种方法将整数转换为字符串，反转字符串，然后转换回整数。它很直观，能处理符号和溢出情况。\n\n## 时间复杂度\n- **时间复杂度**: O(log n) - 其中n是输入数字（数字位数）\n- **空间复杂度**: O(log n) - 用于字符串存储\n\n## 实现代码\n\n```javascript\nfunction reverse(x) {\n  const sign = x < 0 ? -1 : 1;\n  const reversed = parseInt(Math.abs(x).toString().split('').reverse().join(''));\n  \n  // 检查32位整数溢出\n  if (reversed > 2**31 - 1) return 0;\n  \n  return sign * reversed;\n}\n```\n\n## 逐步解释\n\n1. **提取符号**: 存储数字是正数还是负数\n2. **转换为字符串**: 使用 `Math.abs(x).toString()` 获取数字字符串\n3. **反转字符串**: 分割、反转数组、重新连接\n4. **转换回来**: 使用 `parseInt()` 获取整数\n5. **检查溢出**: 如果结果超出32位整数范围则返回0\n6. **应用符号**: 乘以存储的符号\n\n## 示例演示\n\n对于 `x = -123`：\n\n1. sign = -1, abs = 123\n2. toString() = '123'\n3. split('') = ['1', '2', '3']\n4. reverse() = ['3', '2', '1']\n5. join('') = '321'\n6. parseInt('321') = 321\n7. 321 <= 2³¹-1，所以没有溢出\n8. 返回 -1 * 321 = -321\n\n## 优缺点\n\n**优点:**\n- 易于理解和实现\n- 自然处理负数\n- 清晰的溢出检查\n\n**缺点:**\n- 字符串操作可能较慢\n- 字符串转换使用额外空间"
        }
      },
      {
        "title": {
          "en": "Mathematical Approach",
          "zh": "数学方法"
        },
        "content": {
          "en": "# Mathematical Approach\n\n## Algorithm Overview\n\nThis approach reverses the integer mathematically using modulo and division operations without string conversion. It's more efficient in terms of space complexity.\n\n## Time Complexity\n- **Time**: O(log n) - where n is the input number\n- **Space**: O(1) - only uses constant extra space\n\n## Implementation\n\n```javascript\nfunction reverse(x) {\n  let result = 0;\n  let num = Math.abs(x);\n  \n  while (num > 0) {\n    result = result * 10 + num % 10;\n    num = Math.floor(num / 10);\n  }\n  \n  // Check for overflow\n  if (result > 2**31 - 1) return 0;\n  \n  return x < 0 ? -result : result;\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Initialize**: result = 0, num = |x|\n2. **Extract digits**: Use modulo 10 to get last digit\n3. **Build result**: Multiply current result by 10 and add digit\n4. **Remove digit**: Divide num by 10 (integer division)\n5. **Repeat**: Until num becomes 0\n6. **Check overflow**: Return 0 if overflow detected\n7. **Apply sign**: Return negative if original was negative\n\n## Example Walkthrough\n\nFor `x = 123`:\n\n1. result = 0, num = 123\n2. Iteration 1: digit = 3, result = 0*10 + 3 = 3, num = 12\n3. Iteration 2: digit = 2, result = 3*10 + 2 = 32, num = 1\n4. Iteration 3: digit = 1, result = 32*10 + 1 = 321, num = 0\n5. Loop ends, return 321\n\n## Overflow Handling\n\n```javascript\n// More precise overflow check\nif (result > (2**31 - 1) / 10 || \n    (result === Math.floor((2**31 - 1) / 10) && digit > 7)) {\n  return 0;\n}\n```\n\n## Pros and Cons\n\n**Pros:**\n- O(1) space complexity\n- No string conversion overhead\n- Pure mathematical solution\n\n**Cons:**\n- Slightly more complex overflow checking\n- Less intuitive than string approach",
          "zh": "# 数学方法\n\n## 算法概述\n\n这种方法使用模运算和除法运算在数学上反转整数，不需要字符串转换。在空间复杂度方面更加高效。\n\n## 时间复杂度\n- **时间复杂度**: O(log n) - 其中n是输入数字\n- **空间复杂度**: O(1) - 只使用常数额外空间\n\n## 实现代码\n\n```javascript\nfunction reverse(x) {\n  let result = 0;\n  let num = Math.abs(x);\n  \n  while (num > 0) {\n    result = result * 10 + num % 10;\n    num = Math.floor(num / 10);\n  }\n  \n  // 检查溢出\n  if (result > 2**31 - 1) return 0;\n  \n  return x < 0 ? -result : result;\n}\n```\n\n## 逐步解释\n\n1. **初始化**: result = 0, num = |x|\n2. **提取数字**: 使用模10获取最后一位数字\n3. **构建结果**: 将当前结果乘以10并加上数字\n4. **移除数字**: 将num除以10（整数除法）\n5. **重复**: 直到num变为0\n6. **检查溢出**: 如果检测到溢出则返回0\n7. **应用符号**: 如果原数为负则返回负值\n\n## 示例演示\n\n对于 `x = 123`：\n\n1. result = 0, num = 123\n2. 迭代1: digit = 3, result = 0*10 + 3 = 3, num = 12\n3. 迭代2: digit = 2, result = 3*10 + 2 = 32, num = 1\n4. 迭代3: digit = 1, result = 32*10 + 1 = 321, num = 0\n5. 循环结束，返回 321\n\n## 溢出处理\n\n```javascript\n// 更精确的溢出检查\nif (result > (2**31 - 1) / 10 || \n    (result === Math.floor((2**31 - 1) / 10) && digit > 7)) {\n  return 0;\n}\n```\n\n## 优缺点\n\n**优点:**\n- O(1)空间复杂度\n- 没有字符串转换开销\n- 纯数学解决方案\n\n**缺点:**\n- 稍微复杂的溢出检查\n- 不如字符串方法直观"
        }
      }
    ],
    "tests": [
      {
        "input": "123",
        "output": "321"
      },
      {
        "input": "-123",
        "output": "-321"
      },
      {
        "input": "120",
        "output": "21"
      },
      {
        "input": "0",
        "output": "0"
      },
      {
        "input": "1534236469",
        "output": "0"
      },
      {
        "input": "-2147483648",
        "output": "0"
      },
      {
        "input": "1000",
        "output": "1"
      }
    ]
  },
  {
    "id": "palindrome-number",
    "title": {
      "en": "Palindrome Number",
      "zh": "回文数"
    },
    "difficulty": "Easy",
    "tags": [
      "math"
    ],
    "description": {
      "en": "Given an integer x, return true if x is palindrome integer.",
      "zh": "给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。"
    },
    "examples": [
      {
        "input": "x = 121",
        "output": "true"
      },
      {
        "input": "x = -121",
        "output": "false"
      },
      {
        "input": "x = 10",
        "output": "false"
      }
    ],
    "template": {
      "js": "function isPalindrome(x) {\n  // write your code here\n}\nmodule.exports = isPalindrome;",
      "python": "def is_palindrome(x):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public boolean isPalindrome(int x) {\n        // write your code here\n        return false;\n    }\n}",
      "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        // write your code here\n        return false;\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n\nbool isPalindrome(int x) {\n    // write your code here\n    return false;\n}"
    },
    "solution": {
      "js": "function isPalindrome(x) {\n  if (x < 0) return false;\n  const str = x.toString();\n  return str === str.split('').reverse().join('');\n}\nmodule.exports = isPalindrome;"
    },
    "solutions": [
      {
        "title": {
          "en": "String Conversion Approach",
          "zh": "字符串转换方法"
        },
        "content": {
          "en": "# String Conversion Approach\n\n## Algorithm Overview\n\nConvert the number to a string and compare it with its reverse. This is the most straightforward approach.\n\n## Time Complexity\n- **Time**: O(log n) - where n is the input number\n- **Space**: O(log n) - for string storage\n\n## Implementation\n\n```javascript\nfunction isPalindrome(x) {\n  // Negative numbers are not palindromes\n  if (x < 0) return false;\n  \n  const str = x.toString();\n  const reversed = str.split('').reverse().join('');\n  \n  return str === reversed;\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Handle negatives**: Return false immediately for negative numbers\n2. **Convert to string**: Use `toString()` to get string representation\n3. **Reverse string**: Split into array, reverse, and join back\n4. **Compare**: Check if original equals reversed string\n\n## Example Walkthrough\n\nFor `x = 121`:\n\n1. x >= 0, continue\n2. str = '121'\n3. reversed = '121'.split('').reverse().join('') = '121'\n4. '121' === '121' = true\n\nFor `x = 123`:\n\n1. x >= 0, continue\n2. str = '123'\n3. reversed = '321'\n4. '123' === '321' = false\n\n## Pros and Cons\n\n**Pros:**\n- Simple and intuitive\n- Easy to understand and implement\n- Handles edge cases naturally\n\n**Cons:**\n- Uses extra space for string conversion\n- String operations might be slower than arithmetic",
          "zh": "# 字符串转换方法\n\n## 算法概述\n\n将数字转换为字符串并与其反转进行比较。这是最直接的方法。\n\n## 时间复杂度\n- **时间复杂度**: O(log n) - 其中n是输入数字\n- **空间复杂度**: O(log n) - 用于字符串存储\n\n## 实现代码\n\n```javascript\nfunction isPalindrome(x) {\n  // 负数不是回文数\n  if (x < 0) return false;\n  \n  const str = x.toString();\n  const reversed = str.split('').reverse().join('');\n  \n  return str === reversed;\n}\n```\n\n## 逐步解释\n\n1. **处理负数**: 对于负数立即返回false\n2. **转换为字符串**: 使用 `toString()` 获取字符串表示\n3. **反转字符串**: 分割为数组、反转、重新连接\n4. **比较**: 检查原始字符串是否等于反转后的字符串\n\n## 示例演示\n\n对于 `x = 121`：\n\n1. x >= 0，继续\n2. str = '121'\n3. reversed = '121'.split('').reverse().join('') = '121'\n4. '121' === '121' = true\n\n对于 `x = 123`：\n\n1. x >= 0，继续\n2. str = '123'\n3. reversed = '321'\n4. '123' === '321' = false\n\n## 优缺点\n\n**优点:**\n- 简单直观\n- 易于理解和实现\n- 自然处理边界情况\n\n**缺点:**\n- 使用额外空间进行字符串转换\n- 字符串操作可能比算术操作慢"
        }
      },
      {
        "title": {
          "en": "Mathematical Approach",
          "zh": "数学方法"
        },
        "content": {
          "en": "# Mathematical Approach\n\n## Algorithm Overview\n\nReverse the integer mathematically and compare with the original. More space-efficient as it doesn't use string conversion.\n\n## Time Complexity\n- **Time**: O(log n) - where n is the input number\n- **Space**: O(1) - only uses constant extra space\n\n## Implementation\n\n```javascript\nfunction isPalindrome(x) {\n  // Negative numbers and numbers ending in 0 (except 0) are not palindromes\n  if (x < 0 || (x % 10 === 0 && x !== 0)) return false;\n  \n  let reversed = 0;\n  let original = x;\n  \n  while (original > 0) {\n    reversed = reversed * 10 + original % 10;\n    original = Math.floor(original / 10);\n  }\n  \n  return reversed === x;\n}\n```\n\n## Optimized Half-Reversal Approach\n\n```javascript\nfunction isPalindrome(x) {\n  if (x < 0 || (x % 10 === 0 && x !== 0)) return false;\n  \n  let reversedHalf = 0;\n  \n  while (x > reversedHalf) {\n    reversedHalf = reversedHalf * 10 + x % 10;\n    x = Math.floor(x / 10);\n  }\n  \n  // For odd number of digits, we can get rid of the middle digit\n  // by reversedHalf / 10 since the middle digit doesn't matter\n  return x === reversedHalf || x === Math.floor(reversedHalf / 10);\n}\n```\n\n## Step-by-Step Explanation (Half-Reversal)\n\n1. **Handle edge cases**: Negative numbers and multiples of 10\n2. **Reverse half**: Only reverse until we've processed half the digits\n3. **Compare**: Check if remaining equals reversed half\n4. **Handle odd digits**: For odd-length numbers, ignore middle digit\n\n## Example Walkthrough\n\nFor `x = 1221`:\n\n1. Start: x = 1221, reversedHalf = 0\n2. Iteration 1: reversedHalf = 1, x = 122\n3. Iteration 2: reversedHalf = 12, x = 12\n4. Stop (x <= reversedHalf)\n5. Compare: 12 === 12 = true\n\nFor `x = 12321`:\n\n1. Start: x = 12321, reversedHalf = 0\n2. Iteration 1: reversedHalf = 1, x = 1232\n3. Iteration 2: reversedHalf = 12, x = 123\n4. Iteration 3: reversedHalf = 123, x = 12\n5. Stop (x < reversedHalf)\n6. Compare: 12 === Math.floor(123/10) = 12 = true\n\n## Pros and Cons\n\n**Pros:**\n- O(1) space complexity\n- No string conversion overhead\n- Half-reversal optimization reduces operations\n\n**Cons:**\n- More complex logic\n- Requires careful handling of edge cases",
          "zh": "# 数学方法\n\n## 算法概述\n\n在数学上反转整数并与原数进行比较。更加节省空间，因为不使用字符串转换。\n\n## 时间复杂度\n- **时间复杂度**: O(log n) - 其中n是输入数字\n- **空间复杂度**: O(1) - 只使用常数额外空间\n\n## 实现代码\n\n```javascript\nfunction isPalindrome(x) {\n  // 负数和以10结尾的数（除了0）不是回文数\n  if (x < 0 || (x % 10 === 0 && x !== 0)) return false;\n  \n  let reversed = 0;\n  let original = x;\n  \n  while (original > 0) {\n    reversed = reversed * 10 + original % 10;\n    original = Math.floor(original / 10);\n  }\n  \n  return reversed === x;\n}\n```\n\n## 优化的半反转方法\n\n```javascript\nfunction isPalindrome(x) {\n  if (x < 0 || (x % 10 === 0 && x !== 0)) return false;\n  \n  let reversedHalf = 0;\n  \n  while (x > reversedHalf) {\n    reversedHalf = reversedHalf * 10 + x % 10;\n    x = Math.floor(x / 10);\n  }\n  \n  // 对于奇数位数字，我们可以通过 reversedHalf / 10 去掉中间数字\n  // 因为中间数字不影响回文判断\n  return x === reversedHalf || x === Math.floor(reversedHalf / 10);\n}\n```\n\n## 逐步解释（半反转）\n\n1. **处理边界情况**: 负数和10的倍数\n2. **反转一半**: 只反转到处理了一半数字\n3. **比较**: 检查剩余部分是否等于反转的一半\n4. **处理奇数位**: 对于奇数长度，忽略中间数字\n\n## 示例演示\n\n对于 `x = 1221`：\n\n1. 开始: x = 1221, reversedHalf = 0\n2. 迭代1: reversedHalf = 1, x = 122\n3. 迭代2: reversedHalf = 12, x = 12\n4. 停止 (x <= reversedHalf)\n5. 比较: 12 === 12 = true\n\n对于 `x = 12321`：\n\n1. 开始: x = 12321, reversedHalf = 0\n2. 迭代1: reversedHalf = 1, x = 1232\n3. 迭代2: reversedHalf = 12, x = 123\n4. 迭代3: reversedHalf = 123, x = 12\n5. 停止 (x < reversedHalf)\n6. 比较: 12 === Math.floor(123/10) = 12 = true\n\n## 优缺点\n\n**优点:**\n- O(1)空间复杂度\n- 没有字符串转换开销\n- 半反转优化减少操作\n\n**缺点:**\n- 逻辑更复杂\n- 需要仔细处理边界情况"
        }
      }
    ],
    "tests": [
      {
        "input": "121",
        "output": "true"
      },
      {
        "input": "-121",
        "output": "false"
      },
      {
        "input": "10",
        "output": "false"
      },
      {
        "input": "0",
        "output": "true"
      },
      {
        "input": "1",
        "output": "true"
      },
      {
        "input": "1221",
        "output": "true"
      },
      {
        "input": "12321",
        "output": "true"
      },
      {
        "input": "123",
        "output": "false"
      }
    ]
  },
  {
    "id": "longest-common-prefix",
    "title": {
      "en": "Longest Common Prefix",
      "zh": "最长公共前缀"
    },
    "difficulty": "Easy",
    "tags": [
      "string"
    ],
    "description": {
      "en": "Write a function to find the longest common prefix string amongst an array of strings.",
      "zh": "编写一个函数来查找字符串数组中的最长公共前缀。"
    },
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\""
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\""
      }
    ],
    "template": {
      "js": "function longestCommonPrefix(strs) {\n  // write your code here\n}\nmodule.exports = longestCommonPrefix;",
      "python": "def longest_common_prefix(strs):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        // write your code here\n        return \"\";\n    }\n}",
      "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        // write your code here\n        return \"\";\n    }\n};",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* longestCommonPrefix(char** strs, int strsSize) {\n    // write your code here\n    char* result = (char*)malloc(1);\n    result[0] = '\\0';\n    return result;\n}"
    },
    "solution": {
      "js": "function longestCommonPrefix(strs) {\n  if (!strs.length) return '';\n  let prefix = strs[0];\n  for (let i = 1; i < strs.length; i++) {\n    while (strs[i].indexOf(prefix) !== 0) {\n      prefix = prefix.slice(0, -1);\n      if (!prefix) return '';\n    }\n  }\n  return prefix;\n}\nmodule.exports = longestCommonPrefix;"
    },
    "solutions": [
      {
        "title": {
          "en": "Horizontal Scanning",
          "zh": "水平扫描法"
        },
        "content": {
          "en": "# Horizontal Scanning Approach\n\n## Algorithm Overview\n\nStart with the first string as the initial prefix and iteratively shorten it by comparing with each subsequent string until all strings share the common prefix.\n\n## Time Complexity\n- **Time**: O(S) - where S is sum of all characters in all strings\n- **Space**: O(1) - only uses constant extra space\n\n## Implementation\n\n```javascript\nfunction longestCommonPrefix(strs) {\n  if (!strs.length) return '';\n  \n  let prefix = strs[0];\n  \n  for (let i = 1; i < strs.length; i++) {\n    while (strs[i].indexOf(prefix) !== 0) {\n      prefix = prefix.slice(0, -1);\n      if (!prefix) return '';\n    }\n  }\n  \n  return prefix;\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Handle edge case**: Return empty string if array is empty\n2. **Initialize prefix**: Use first string as initial prefix\n3. **Compare with each string**: For each remaining string:\n   - Check if current prefix is at the start\n   - If not, remove last character from prefix\n   - Repeat until match or prefix becomes empty\n4. **Return result**: Final prefix is the answer\n\n## Example Walkthrough\n\nFor `strs = ['flower', 'flow', 'flight']`:\n\n1. prefix = 'flower'\n2. Compare with 'flow':\n   - 'flow'.indexOf('flower') = -1 ≠ 0\n   - prefix = 'flowe'\n   - 'flow'.indexOf('flowe') = -1 ≠ 0\n   - prefix = 'flow'\n   - 'flow'.indexOf('flow') = 0 ✓\n3. Compare with 'flight':\n   - 'flight'.indexOf('flow') = -1 ≠ 0\n   - prefix = 'flo'\n   - 'flight'.indexOf('flo') = -1 ≠ 0\n   - prefix = 'fl'\n   - 'flight'.indexOf('fl') = 0 ✓\n4. Return 'fl'\n\n## Optimization Tips\n\n- Early termination when prefix becomes empty\n- Use `startsWith()` method for better readability:\n\n```javascript\nwhile (!strs[i].startsWith(prefix)) {\n  prefix = prefix.slice(0, -1);\n  if (!prefix) return '';\n}\n```\n\n## Pros and Cons\n\n**Pros:**\n- Simple and intuitive approach\n- Easy to understand and implement\n- Works well for most practical cases\n\n**Cons:**\n- Worst case requires checking all characters\n- May do redundant comparisons in some cases",
          "zh": "# 水平扫描方法\n\n## 算法概述\n\n以第一个字符串作为初始前缀，通过与每个后续字符串比较来迭代地缩短它，直到所有字符串都共享公共前缀。\n\n## 时间复杂度\n- **时间复杂度**: O(S) - 其中S是所有字符串中所有字符的总和\n- **空间复杂度**: O(1) - 只使用常数额外空间\n\n## 实现代码\n\n```javascript\nfunction longestCommonPrefix(strs) {\n  if (!strs.length) return '';\n  \n  let prefix = strs[0];\n  \n  for (let i = 1; i < strs.length; i++) {\n    while (strs[i].indexOf(prefix) !== 0) {\n      prefix = prefix.slice(0, -1);\n      if (!prefix) return '';\n    }\n  }\n  \n  return prefix;\n}\n```\n\n## 逐步解释\n\n1. **处理边界情况**: 如果数组为空则返回空字符串\n2. **初始化前缀**: 使用第一个字符串作为初始前缀\n3. **与每个字符串比较**: 对于每个剩余字符串：\n   - 检查当前前缀是否在开头\n   - 如果不是，从前缀中移除最后一个字符\n   - 重复直到匹配或前缀变为空\n4. **返回结果**: 最终前缀就是答案\n\n## 示例演示\n\n对于 `strs = ['flower', 'flow', 'flight']`：\n\n1. prefix = 'flower'\n2. 与'flow'比较：\n   - 'flow'.indexOf('flower') = -1 ≠ 0\n   - prefix = 'flowe'\n   - 'flow'.indexOf('flowe') = -1 ≠ 0\n   - prefix = 'flow'\n   - 'flow'.indexOf('flow') = 0 ✓\n3. 与'flight'比较：\n   - 'flight'.indexOf('flow') = -1 ≠ 0\n   - prefix = 'flo'\n   - 'flight'.indexOf('flo') = -1 ≠ 0\n   - prefix = 'fl'\n   - 'flight'.indexOf('fl') = 0 ✓\n4. 返回 'fl'\n\n## 优化提示\n\n- 当前缀变为空时提前终止\n- 使用 `startsWith()` 方法提高可读性：\n\n```javascript\nwhile (!strs[i].startsWith(prefix)) {\n  prefix = prefix.slice(0, -1);\n  if (!prefix) return '';\n}\n```\n\n## 优缺点\n\n**优点:**\n- 简单直观的方法\n- 易于理解和实现\n- 在大多数实际情况下表现良好\n\n**缺点:**\n- 最坏情况需要检查所有字符\n- 在某些情况下可能进行冗余比较"
        }
      },
      {
        "title": {
          "en": "Vertical Scanning",
          "zh": "垂直扫描法"
        },
        "content": {
          "en": "# Vertical Scanning Approach\n\n## Algorithm Overview\n\nCompare characters from the same position across all strings, character by character, until a mismatch is found.\n\n## Time Complexity\n- **Time**: O(S) - where S is sum of all characters in all strings\n- **Space**: O(1) - only uses constant extra space\n\n## Implementation\n\n```javascript\nfunction longestCommonPrefix(strs) {\n  if (!strs.length) return '';\n  \n  for (let i = 0; i < strs[0].length; i++) {\n    const char = strs[0][i];\n    \n    for (let j = 1; j < strs.length; j++) {\n      // Check if we've reached end of current string or characters don't match\n      if (i === strs[j].length || strs[j][i] !== char) {\n        return strs[0].substring(0, i);\n      }\n    }\n  }\n  \n  return strs[0];\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Handle edge case**: Return empty string if array is empty\n2. **Iterate by position**: For each character position in first string:\n3. **Get reference character**: Take character at current position from first string\n4. **Check all strings**: Compare character at same position in all other strings\n5. **Early termination**: If any string is shorter or has different character, return prefix so far\n6. **Complete match**: If all positions match, return entire first string\n\n## Example Walkthrough\n\nFor `strs = ['flower', 'flow', 'flight']`:\n\n1. i=0, char='f': Check 'f' in all strings ✓\n2. i=1, char='l': Check 'l' in all strings ✓\n3. i=2, char='o': \n   - 'flow'[2] = 'o' ✓\n   - 'flight'[2] = 'i' ≠ 'o' ✗\n4. Return strs[0].substring(0, 2) = 'fl'\n\n## Optimized Early Exit\n\n```javascript\nfunction longestCommonPrefix(strs) {\n  if (!strs.length) return '';\n  \n  // Find minimum length to avoid unnecessary checks\n  let minLen = Math.min(...strs.map(s => s.length));\n  \n  for (let i = 0; i < minLen; i++) {\n    const char = strs[0][i];\n    for (let j = 1; j < strs.length; j++) {\n      if (strs[j][i] !== char) {\n        return strs[0].substring(0, i);\n      }\n    }\n  }\n  \n  return strs[0].substring(0, minLen);\n}\n```\n\n## Pros and Cons\n\n**Pros:**\n- Can terminate early when mismatch found\n- Intuitive column-by-column comparison\n- No redundant string operations\n\n**Cons:**\n- Requires nested loops\n- May access characters multiple times in worst case",
          "zh": "# 垂直扫描方法\n\n## 算法概述\n\n逐个字符比较所有字符串同一位置的字符，直到发现不匹配。\n\n## 时间复杂度\n- **时间复杂度**: O(S) - 其中S是所有字符串中所有字符的总和\n- **空间复杂度**: O(1) - 只使用常数额外空间\n\n## 实现代码\n\n```javascript\nfunction longestCommonPrefix(strs) {\n  if (!strs.length) return '';\n  \n  for (let i = 0; i < strs[0].length; i++) {\n    const char = strs[0][i];\n    \n    for (let j = 1; j < strs.length; j++) {\n      // 检查是否已达到当前字符串的结尾或字符不匹配\n      if (i === strs[j].length || strs[j][i] !== char) {\n        return strs[0].substring(0, i);\n      }\n    }\n  }\n  \n  return strs[0];\n}\n```\n\n## 逐步解释\n\n1. **处理边界情况**: 如果数组为空则返回空字符串\n2. **按位置迭代**: 对于第一个字符串中的每个字符位置：\n3. **获取参考字符**: 从第一个字符串中取当前位置的字符\n4. **检查所有字符串**: 比较所有其他字符串同一位置的字符\n5. **提前终止**: 如果任何字符串较短或有不同字符，返回到目前为止的前缀\n6. **完全匹配**: 如果所有位置都匹配，返回整个第一个字符串\n\n## 示例演示\n\n对于 `strs = ['flower', 'flow', 'flight']`：\n\n1. i=0, char='f': 检查所有字符串中的'f' ✓\n2. i=1, char='l': 检查所有字符串中的'l' ✓\n3. i=2, char='o': \n   - 'flow'[2] = 'o' ✓\n   - 'flight'[2] = 'i' ≠ 'o' ✗\n4. 返回 strs[0].substring(0, 2) = 'fl'\n\n## 优化的提前退出\n\n```javascript\nfunction longestCommonPrefix(strs) {\n  if (!strs.length) return '';\n  \n  // 找到最小长度以避免不必要的检查\n  let minLen = Math.min(...strs.map(s => s.length));\n  \n  for (let i = 0; i < minLen; i++) {\n    const char = strs[0][i];\n    for (let j = 1; j < strs.length; j++) {\n      if (strs[j][i] !== char) {\n        return strs[0].substring(0, i);\n      }\n    }\n  }\n  \n  return strs[0].substring(0, minLen);\n}\n```\n\n## 优缺点\n\n**优点:**\n- 可以在发现不匹配时提前终止\n- 直观的逐列比较\n- 没有冗余的字符串操作\n\n**缺点:**\n- 需要嵌套循环\n- 在最坏情况下可能多次访问字符"
        }
      }
    ],
    "tests": [
      {
        "input": "[\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\""
      },
      {
        "input": "[\"dog\",\"racecar\",\"car\"]",
        "output": "\"\""
      },
      {
        "input": "[\"ab\", \"a\"]",
        "output": "\"a\""
      }
    ]
  },
  {
    "id": "valid-parentheses",
    "title": {
      "en": "Valid Parentheses",
      "zh": "有效的括号"
    },
    "difficulty": "Easy",
    "tags": [
      "string",
      "stack"
    ],
    "description": {
      "en": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
      "zh": "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。"
    },
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true"
      },
      {
        "input": "s = \"(]\"",
        "output": "false"
      }
    ],
    "template": {
      "js": "function isValid(s) {\n  // write your code here\n}\nmodule.exports = isValid;",
      "python": "def is_valid(s):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public boolean isValid(String s) {\n        // write your code here\n        return false;\n    }\n}",
      "cpp": "#include <string>\n#include <stack>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        // write your code here\n        return false;\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool isValid(char* s) {\n    // write your code here\n    return false;\n}"
    },
    "solution": {
      "js": "function isValid(s) {\n  const stack = [];\n  const map = { ')': '(', '}': '{', ']': '[' };\n  for (let char of s) {\n    if (char in map) {\n      if (stack.pop() !== map[char]) return false;\n    } else {\n      stack.push(char);\n    }\n  }\n  return stack.length === 0;\n}\nmodule.exports = isValid;"
    },
    "solutions": [
      {
        "title": {
          "en": "Stack Approach",
          "zh": "栈方法"
        },
        "content": {
          "en": "# Stack Approach\n\n## Algorithm Overview\n\nUse a stack to track opening brackets and match them with closing brackets. This is the standard and most efficient approach for the parentheses matching problem.\n\n## Time Complexity\n- **Time**: O(n) - Single pass through the string\n- **Space**: O(n) - Stack can hold up to n/2 opening brackets\n\n## Implementation\n\n```javascript\nfunction isValid(s) {\n  const stack = [];\n  const map = { ')': '(', '}': '{', ']': '[' };\n  \n  for (let char of s) {\n    if (char in map) {\n      if (stack.pop() !== map[char]) {\n        return false;\n      }\n    } else {\n      stack.push(char);\n    }\n  }\n  \n  return stack.length === 0;\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Initialize stack**: Empty array to store opening brackets\n2. **Create mapping**: Map closing brackets to their opening counterparts\n3. **Iterate through string**: For each character:\n   - If closing bracket: pop from stack and check if it matches\n   - If opening bracket: push to stack\n4. **Final check**: Stack should be empty if all brackets are matched\n\n## Example Walkthrough\n\nFor s = \"([])\":\n\n1. char = '(': Push to stack → ['(']\n2. char = '[': Push to stack → ['(', '[']\n3. char = ']': Pop '[', matches map[']'] = '[' ✓ → ['(']\n4. char = ')': Pop '(', matches map[')'] = '(' ✓ → []\n5. Stack is empty → return true\n\nFor s = \"([)]\":\n\n1. char = '(': Push to stack → ['(']\n2. char = '[': Push to stack → ['(', '[']\n3. char = ')': Pop '[', map[')'] = '(' ≠ '[' ✗ → return false\n\n## Edge Cases\n\n- **Empty string**: Returns true (valid by definition)\n- **Only opening brackets**: Stack not empty, returns false\n- **Only closing brackets**: Stack becomes empty prematurely, returns false\n- **Mismatched types**: Different bracket types don't match",
          "zh": "# 栈方法\n\n## 算法概述\n\n使用栈来跟踪开括号并与闭括号进行匹配。这是括号匹配问题的标准且最高效的方法。\n\n## 时间复杂度\n- **时间复杂度**: O(n) - 单次遍历字符串\n- **空间复杂度**: O(n) - 栈最多可以保存 n/2 个开括号\n\n## 实现代码\n\n```javascript\nfunction isValid(s) {\n  const stack = [];\n  const map = { ')': '(', '}': '{', ']': '[' };\n  \n  for (let char of s) {\n    if (char in map) {\n      if (stack.pop() !== map[char]) {\n        return false;\n      }\n    } else {\n      stack.push(char);\n    }\n  }\n  \n  return stack.length === 0;\n}\n```\n\n## 逐步解释\n\n1. **初始化栈**: 空数组存储开括号\n2. **创建映射**: 将闭括号映射到对应的开括号\n3. **遍历字符串**: 对每个字符：\n   - 如果是闭括号：从栈中弹出并检查是否匹配\n   - 如果是开括号：推入栈\n4. **最终检查**: 如果所有括号都匹配，栈应该为空\n\n## 示例演示\n\n对于 s = \"([])\":\n\n1. char = '(': 推入栈 → ['(']\n2. char = '[': 推入栈 → ['(', '[']\n3. char = ']': 弹出 '[', 匹配 map[']'] = '[' ✓ → ['(']\n4. char = ')': 弹出 '(', 匹配 map[')'] = '(' ✓ → []\n5. 栈为空 → 返回 true\n\n对于 s = \"([)]\":\n\n1. char = '(': 推入栈 → ['(']\n2. char = '[': 推入栈 → ['(', '[']\n3. char = ')': 弹出 '[', map[')'] = '(' ≠ '[' ✗ → 返回 false\n\n## 边界情况\n\n- **空字符串**: 返回 true（按定义有效）\n- **只有开括号**: 栈不为空，返回 false\n- **只有闭括号**: 栈过早变空，返回 false\n- **类型不匹配**: 不同括号类型不匹配"
        }
      }
    ],
    "tests": [
      {
        "input": "\"()\"",
        "output": "true"
      },
      {
        "input": "\"()[]{}\"",
        "output": "true"
      },
      {
        "input": "\"(]\"",
        "output": "false"
      }
    ]
  },
  {
    "id": "merge-sorted-lists",
    "title": {
      "en": "Merge Two Sorted Lists",
      "zh": "合并两个有序链表"
    },
    "difficulty": "Easy",
    "tags": [
      "linked-list",
      "recursion"
    ],
    "description": {
      "en": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a sorted list.",
      "zh": "将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"
    },
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]"
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]"
      }
    ],
    "template": {
      "js": "// Definition for singly-linked list\nfunction ListNode(val, next) {\n  this.val = (val===undefined ? 0 : val);\n  this.next = (next===undefined ? null : next);\n}\n\nfunction mergeTwoLists(list1, list2) {\n  // write your code here\n}\nmodule.exports = mergeTwoLists;",
      "python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_two_lists(list1, list2):\n    # write your code here\n    pass",
      "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic class Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        // write your code here\n        return null;\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        // write your code here\n        return nullptr;\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\nstruct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {\n    // write your code here\n    return NULL;\n}"
    },
    "solution": {
      "js": "function ListNode(val, next) {\n  this.val = (val===undefined ? 0 : val);\n  this.next = (next===undefined ? null : next);\n}\n\nfunction mergeTwoLists(list1, list2) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  while (list1 && list2) {\n    if (list1.val <= list2.val) {\n      current.next = list1;\n      list1 = list1.next;\n    } else {\n      current.next = list2;\n      list2 = list2.next;\n    }\n    current = current.next;\n  }\n  current.next = list1 || list2;\n  return dummy.next;\n}\nmodule.exports = mergeTwoLists;"
    },
    "solutions": [
      {
        "title": {
          "en": "Iterative Approach",
          "zh": "迭代方法"
        },
        "content": {
          "en": "# Iterative Approach\n\n## Algorithm Overview\n\nUse a dummy node and two pointers to iteratively merge the two sorted linked lists by comparing values and connecting nodes.\n\n## Time Complexity\n- **Time**: O(m + n) - where m and n are lengths of the two lists\n- **Space**: O(1) - only uses constant extra space\n\n## Implementation\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  \n  while (list1 && list2) {\n    if (list1.val <= list2.val) {\n      current.next = list1;\n      list1 = list1.next;\n    } else {\n      current.next = list2;\n      list2 = list2.next;\n    }\n    current = current.next;\n  }\n  \n  // Attach remaining nodes\n  current.next = list1 || list2;\n  \n  return dummy.next;\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Create dummy node**: Simplifies edge case handling\n2. **Initialize pointer**: Current pointer to build result list\n3. **Compare and connect**: While both lists have nodes:\n   - Compare current values\n   - Connect smaller node to result\n   - Move pointer in the list with smaller value\n4. **Handle remaining**: Connect any remaining nodes\n5. **Return result**: Skip dummy node and return actual head\n\n## Example Walkthrough\n\nFor list1 = [1,2,4], list2 = [1,3,4]:\n\n1. dummy = [0], current = dummy\n2. Compare 1 ≤ 1: connect list1[1], move list1 → [0,1]\n3. Compare 2 > 1: connect list2[1], move list2 → [0,1,1]\n4. Compare 2 ≤ 3: connect list1[2], move list1 → [0,1,1,2]\n5. Compare 4 > 3: connect list2[3], move list2 → [0,1,1,2,3]\n6. Compare 4 ≤ 4: connect list1[4], move list1 → [0,1,1,2,3,4]\n7. list1 is null: connect remaining list2[4] → [0,1,1,2,3,4,4]\n8. Return dummy.next → [1,1,2,3,4,4]\n\n## Key Techniques\n\n**Dummy Node Pattern:**\n- Eliminates special case handling for empty result\n- Provides stable starting point for list building\n- Common technique in linked list problems\n\n**Two Pointer Technique:**\n- One pointer for each input list\n- One pointer for result list construction\n- Efficient O(1) space usage",
          "zh": "# 迭代方法\n\n## 算法概述\n\n使用哑元节点和两个指针通过比较值和连接节点来迭代地合并两个有序链表。\n\n## 时间复杂度\n- **时间复杂度**: O(m + n) - 其中m和n是两个链表的长度\n- **空间复杂度**: O(1) - 只使用常数额外空间\n\n## 实现代码\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  \n  while (list1 && list2) {\n    if (list1.val <= list2.val) {\n      current.next = list1;\n      list1 = list1.next;\n    } else {\n      current.next = list2;\n      list2 = list2.next;\n    }\n    current = current.next;\n  }\n  \n  // 附加剩余节点\n  current.next = list1 || list2;\n  \n  return dummy.next;\n}\n```\n\n## 逐步解释\n\n1. **创建哑元节点**: 简化边界情况处理\n2. **初始化指针**: 当前指针用于构建结果链表\n3. **比较和连接**: 当两个链表都有节点时：\n   - 比较当前值\n   - 将较小节点连接到结果\n   - 移动有较小值的链表指针\n4. **处理剩余**: 连接任何剩余节点\n5. **返回结果**: 跳过哑元节点返回实际头部\n\n## 示例演示\n\n对于 list1 = [1,2,4], list2 = [1,3,4]:\n\n1. dummy = [0], current = dummy\n2. 比较 1 ≤ 1: 连接 list1[1], 移动 list1 → [0,1]\n3. 比较 2 > 1: 连接 list2[1], 移动 list2 → [0,1,1]\n4. 比較 2 ≤ 3: 连接 list1[2], 移动 list1 → [0,1,1,2]\n5. 比较 4 > 3: 连接 list2[3], 移动 list2 → [0,1,1,2,3]\n6. 比较 4 ≤ 4: 连接 list1[4], 移动 list1 → [0,1,1,2,3,4]\n7. list1 为空: 连接剩余 list2[4] → [0,1,1,2,3,4,4]\n8. 返回 dummy.next → [1,1,2,3,4,4]\n\n## 关键技术\n\n**哑元节点模式:**\n- 消除空结果的特殊情况处理\n- 为链表构建提供稳定起点\n- 链表问题中的常用技术\n\n**双指针技术:**\n- 每个输入链表一个指针\n- 一个指针用于结果链表构建\n- 高效的 O(1) 空间使用"
        }
      },
      {
        "title": {
          "en": "Recursive Approach",
          "zh": "递归方法"
        },
        "content": {
          "en": "# Recursive Approach\n\n## Algorithm Overview\n\nUse recursion to merge lists by making decisions at each step: choose the smaller head and recursively merge the rest.\n\n## Time Complexity\n- **Time**: O(m + n) - Each node is visited once\n- **Space**: O(m + n) - Due to recursion call stack\n\n## Implementation\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n  // Base cases\n  if (!list1) return list2;\n  if (!list2) return list1;\n  \n  // Recursive case\n  if (list1.val <= list2.val) {\n    list1.next = mergeTwoLists(list1.next, list2);\n    return list1;\n  } else {\n    list2.next = mergeTwoLists(list1, list2.next);\n    return list2;\n  }\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Base cases**: \n   - If one list is empty, return the other\n   - These terminate the recursion\n2. **Comparison**: Compare current heads of both lists\n3. **Recursive call**: \n   - Choose the smaller head\n   - Recursively merge remaining lists\n   - Connect chosen node to merged result\n4. **Return**: The chosen node becomes part of result\n\n## Example Walkthrough\n\nFor list1 = [1,4], list2 = [2,3]:\n\n```\nmergeTwoLists([1,4], [2,3])\n│\n├─ 1 ≤ 2, choose 1\n│  1.next = mergeTwoLists([4], [2,3])\n│            │\n│            ├─ 4 > 2, choose 2\n│            │  2.next = mergeTwoLists([4], [3])\n│            │           │\n│            │           ├─ 4 > 3, choose 3\n│            │           │  3.next = mergeTwoLists([4], null)\n│            │           │           │\n│            │           │           └─ return [4]\n│            │           │\n│            │           └─ return [3,4]\n│            │\n│            └─ return [2,3,4]\n│\n└─ return [1,2,3,4]\n```\n\n## Pros and Cons\n\n**Pros:**\n- Clean and elegant solution\n- Easy to understand the logic\n- Natural divide-and-conquer approach\n- Concise code\n\n**Cons:**\n- Uses O(m + n) extra space for call stack\n- May cause stack overflow for very long lists\n- Less memory efficient than iterative approach\n\n## When to Use\n\n- **Small to medium lists**: When stack space isn't a concern\n- **Learning purposes**: Great for understanding recursion\n- **Clean code preference**: When readability is prioritized\n- **Functional programming**: Fits functional paradigm better",
          "zh": "# 递归方法\n\n## 算法概述\n\n使用递归在每一步做决定来合并链表：选择较小的头节点，递归地合并剩余部分。\n\n## 时间复杂度\n- **时间复杂度**: O(m + n) - 每个节点访问一次\n- **空间复杂度**: O(m + n) - 由于递归调用栈\n\n## 实现代码\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n  // 基本情况\n  if (!list1) return list2;\n  if (!list2) return list1;\n  \n  // 递归情况\n  if (list1.val <= list2.val) {\n    list1.next = mergeTwoLists(list1.next, list2);\n    return list1;\n  } else {\n    list2.next = mergeTwoLists(list1, list2.next);\n    return list2;\n  }\n}\n```\n\n## 逐步解释\n\n1. **基本情况**: \n   - 如果一个链表为空，返回另一个\n   - 这些终止递归\n2. **比较**: 比较两个链表的当前头节点\n3. **递归调用**: \n   - 选择较小的头节点\n   - 递归地合并剩余链表\n   - 将选择的节点连接到合并结果\n4. **返回**: 选择的节点成为结果的一部分\n\n## 示例演示\n\n对于 list1 = [1,4], list2 = [2,3]:\n\n```\nmergeTwoLists([1,4], [2,3])\n│\n├─ 1 ≤ 2, 选择 1\n│  1.next = mergeTwoLists([4], [2,3])\n│            │\n│            ├─ 4 > 2, 选择 2\n│            │  2.next = mergeTwoLists([4], [3])\n│            │           │\n│            │           ├─ 4 > 3, 选择 3\n│            │           │  3.next = mergeTwoLists([4], null)\n│            │           │           │\n│            │           │           └─ 返回 [4]\n│            │           │\n│            │           └─ 返回 [3,4]\n│            │\n│            └─ 返回 [2,3,4]\n│\n└─ 返回 [1,2,3,4]\n```\n\n## 优缺点\n\n**优点:**\n- 简洁优雅的解决方案\n- 易于理解逻辑\n- 自然的分治方法\n- 代码简洁\n\n**缺点:**\n- 使用 O(m + n) 额外空间用于调用栈\n- 对于非常长的链表可能导致栈溢出\n- 比迭代方法内存效率低\n\n## 使用场景\n\n- **中小型链表**: 当栈空间不是问题时\n- **学习目的**: 非常适合理解递归\n- **代码清晰偏好**: 当优先考虑可读性时\n- **函数式编程**: 更符合函数式范式"
        }
      }
    ],
    "tests": [
      {
        "input": "[1,2,4],[1,3,4]",
        "output": "[1,1,2,3,4,4]"
      },
      {
        "input": "[],[]",
        "output": "[]"
      },
      {
        "input": "[],[0]",
        "output": "[0]"
      }
    ]
  },
  {
    "id": "remove-duplicates",
    "title": {
      "en": "Remove Duplicates from Sorted Array",
      "zh": "删除有序数组中的重复项"
    },
    "difficulty": "Easy",
    "tags": [
      "array",
      "two-pointers"
    ],
    "description": {
      "en": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once.",
      "zh": "给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。"
    },
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2, nums = [1,2,_]"
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]"
      }
    ],
    "template": {
      "js": "function removeDuplicates(nums) {\n  // write your code here\n}\nmodule.exports = removeDuplicates;",
      "python": "def removeDuplicates(param):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public /* return_type */ removeDuplicates(/* parameters */) {\n        // write your code here\n    }\n}",
      "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    /* return_type */ removeDuplicates(/* parameters */) {\n        // write your code here\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n/* return_type */ removeDuplicates(/* parameters */) {\n    // write your code here\n}"
    },
    "solution": {
      "js": "function removeDuplicates(nums) {\n  if (nums.length === 0) return 0;\n  let i = 0;\n  for (let j = 1; j < nums.length; j++) {\n    if (nums[j] !== nums[i]) {\n      i++;\n      nums[i] = nums[j];\n    }\n  }\n  return i + 1;\n}\nmodule.exports = removeDuplicates;"
    },
    "solutions": [
      {
        "title": {
          "en": "Two Pointers Approach",
          "zh": "双指针方法"
        },
        "content": {
          "en": "# Two Pointers Approach\n\n## Algorithm Overview\n\nUse two pointers: one slow pointer to track unique elements' position, and one fast pointer to scan through the array. This in-place algorithm maintains the array's sorted property while removing duplicates.\n\n## Time Complexity\n- **Time**: O(n) - Single pass through the array\n- **Space**: O(1) - In-place modification, only constant extra space\n\n## Implementation\n\n```javascript\nfunction removeDuplicates(nums) {\n  if (nums.length === 0) return 0;\n  \n  let i = 0; // Slow pointer for unique elements\n  \n  for (let j = 1; j < nums.length; j++) { // Fast pointer\n    if (nums[j] !== nums[i]) {\n      i++;\n      nums[i] = nums[j];\n    }\n  }\n  \n  return i + 1; // Length of array with unique elements\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Handle edge case**: Return 0 for empty array\n2. **Initialize pointers**: \n   - `i` (slow): Points to last unique element position\n   - `j` (fast): Scans through array starting from index 1\n3. **Compare elements**: If `nums[j] !== nums[i]`, found new unique element\n4. **Update position**: Increment `i` and place new unique element at `nums[i]`\n5. **Return length**: `i + 1` is the count of unique elements\n\n## Example Walkthrough\n\nFor `nums = [0,0,1,1,1,2,2,3,3,4]`:\n\n```\nInitial: [0,0,1,1,1,2,2,3,3,4]\n         i\nStep 1: j=1, nums[1]=0 = nums[0]=0, skip\n        [0,0,1,1,1,2,2,3,3,4]\n         i   j\n\nStep 2: j=2, nums[2]=1 ≠ nums[0]=0, update\n        [0,1,1,1,1,2,2,3,3,4]\n           i   j\n\nStep 3: j=3, nums[3]=1 = nums[1]=1, skip\n        [0,1,1,1,1,2,2,3,3,4]\n           i     j\n\nStep 4: j=4, nums[4]=1 = nums[1]=1, skip\n        [0,1,1,1,1,2,2,3,3,4]\n           i       j\n\nStep 5: j=5, nums[5]=2 ≠ nums[1]=1, update\n        [0,1,2,1,1,2,2,3,3,4]\n             i       j\n\nStep 6: j=6, nums[6]=2 = nums[2]=2, skip\n        [0,1,2,1,1,2,2,3,3,4]\n             i         j\n\nStep 7: j=7, nums[7]=3 ≠ nums[2]=2, update\n        [0,1,2,3,1,2,2,3,3,4]\n               i         j\n\nStep 8: j=8, nums[8]=3 = nums[3]=3, skip\n        [0,1,2,3,1,2,2,3,3,4]\n               i           j\n\nStep 9: j=9, nums[9]=4 ≠ nums[3]=3, update\n        [0,1,2,3,4,2,2,3,3,4]\n                 i           j\n\nFinal: [0,1,2,3,4,_,_,_,_,_], return 5\n```\n\n## Key Insights\n\n**In-place Modification:**\n- We overwrite duplicate positions with unique values\n- Only the first k positions contain the final result\n- Remaining positions can contain any values\n\n**Sorted Array Property:**\n- Duplicates are always adjacent in sorted arrays\n- We only need to compare with the previous unique element\n- No need to check all previous elements",
          "zh": "# 双指针方法\n\n## 算法概述\n\n使用两个指针：一个慢指针跟踪唯一元素的位置，一个快指针扫描数组。这个原地算法在删除重复元素的同时保持数组的排序属性。\n\n## 时间复杂度\n- **时间复杂度**: O(n) - 单次遍历数组\n- **空间复杂度**: O(1) - 原地修改，只用常数额外空间\n\n## 实现代码\n\n```javascript\nfunction removeDuplicates(nums) {\n  if (nums.length === 0) return 0;\n  \n  let i = 0; // 慢指针用于唯一元素\n  \n  for (let j = 1; j < nums.length; j++) { // 快指针\n    if (nums[j] !== nums[i]) {\n      i++;\n      nums[i] = nums[j];\n    }\n  }\n  \n  return i + 1; // 唯一元素数组的长度\n}\n```\n\n## 逐步解释\n\n1. **处理边界情况**: 空数组返回 0\n2. **初始化指针**: \n   - `i` (慢): 指向最后一个唯一元素位置\n   - `j` (快): 从索引 1 开始扫描数组\n3. **比较元素**: 如果 `nums[j] !== nums[i]`，找到新的唯一元素\n4. **更新位置**: 递增 `i` 并在 `nums[i]` 放置新的唯一元素\n5. **返回长度**: `i + 1` 是唯一元素的数量\n\n## 示例演示\n\n对于 `nums = [0,0,1,1,1,2,2,3,3,4]`:\n\n```\n初始: [0,0,1,1,1,2,2,3,3,4]\n         i\n步骤 1: j=1, nums[1]=0 = nums[0]=0, 跳过\n        [0,0,1,1,1,2,2,3,3,4]\n         i   j\n\n步骤 2: j=2, nums[2]=1 ≠ nums[0]=0, 更新\n        [0,1,1,1,1,2,2,3,3,4]\n           i   j\n\n步骤 3: j=3, nums[3]=1 = nums[1]=1, 跳过\n        [0,1,1,1,1,2,2,3,3,4]\n           i     j\n\n步骤 4: j=4, nums[4]=1 = nums[1]=1, 跳过\n        [0,1,1,1,1,2,2,3,3,4]\n           i       j\n\n步骤 5: j=5, nums[5]=2 ≠ nums[1]=1, 更新\n        [0,1,2,1,1,2,2,3,3,4]\n             i       j\n\n步骤 6: j=6, nums[6]=2 = nums[2]=2, 跳过\n        [0,1,2,1,1,2,2,3,3,4]\n             i         j\n\n步骤 7: j=7, nums[7]=3 ≠ nums[2]=2, 更新\n        [0,1,2,3,1,2,2,3,3,4]\n               i         j\n\n步骤 8: j=8, nums[8]=3 = nums[3]=3, 跳过\n        [0,1,2,3,1,2,2,3,3,4]\n               i           j\n\n步骤 9: j=9, nums[9]=4 ≠ nums[3]=3, 更新\n        [0,1,2,3,4,2,2,3,3,4]\n                 i           j\n\n最终: [0,1,2,3,4,_,_,_,_,_], 返回 5\n```\n\n## 关键洞察\n\n**原地修改:**\n- 我们用唯一值覆盖重复位置\n- 只有前 k 个位置包含最终结果\n- 剩余位置可以包含任何值\n\n**有序数组属性:**\n- 在有序数组中重复元素总是相邻的\n- 我们只需要与前一个唯一元素比较\n- 不需要检查所有之前的元素"
        }
      },
      {
        "title": {
          "en": "Set-based Approach",
          "zh": "集合方法"
        },
        "content": {
          "en": "# Set-based Approach\n\n## Algorithm Overview\n\nUse a Set to track unique elements and rebuild the array. While this approach is intuitive, it doesn't meet the problem's in-place requirement but is useful for understanding the concept.\n\n**Note**: This approach doesn't satisfy the O(1) space complexity requirement but is included for educational purposes.\n\n## Time Complexity\n- **Time**: O(n) - Single pass to build set, another to rebuild array\n- **Space**: O(n) - Set can store up to n unique elements\n\n## Implementation\n\n```javascript\n// Warning: This doesn't meet the in-place requirement!\nfunction removeDuplicates(nums) {\n  if (nums.length === 0) return 0;\n  \n  const uniqueSet = new Set();\n  \n  // Collect unique elements\n  for (let num of nums) {\n    uniqueSet.add(num);\n  }\n  \n  // Rebuild array with unique elements\n  const uniqueArray = [...uniqueSet].sort((a, b) => a - b);\n  \n  // Copy back to original array\n  for (let i = 0; i < uniqueArray.length; i++) {\n    nums[i] = uniqueArray[i];\n  }\n  \n  return uniqueArray.length;\n}\n```\n\n## Why This Approach Has Issues\n\n1. **Space Complexity**: Uses O(n) extra space for the Set\n2. **Sorting Required**: Set doesn't maintain insertion order for numbers\n3. **Not In-place**: Creates additional data structures\n4. **Inefficient**: Multiple passes through data\n\n## Optimized Set Approach\n\n```javascript\n// Still not in-place, but more efficient\nfunction removeDuplicates(nums) {\n  if (nums.length === 0) return 0;\n  \n  const seen = new Set();\n  let writeIndex = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    if (!seen.has(nums[i])) {\n      seen.add(nums[i]);\n      nums[writeIndex] = nums[i];\n      writeIndex++;\n    }\n  }\n  \n  return writeIndex;\n}\n```\n\n## Comparison with Two Pointers\n\n| Approach | Time | Space | In-place | Optimal |\n|----------|------|-------|----------|---------|\n| Two Pointers | O(n) | O(1) | Yes | ✓ |\n| Set-based | O(n) | O(n) | No | ✗ |\n\n## When Set Approach is Useful\n\n- **Unsorted Arrays**: When array is not sorted, two pointers won't work\n- **Learning**: Understanding the difference between approaches\n- **Preprocessing**: When you need to work with unsorted data first\n\n## Key Takeaway\n\nFor this specific problem (sorted array, in-place requirement), the **two pointers approach is optimal**. The set-based approach violates the space complexity constraint but helps understand the problem conceptually.",
          "zh": "# 集合方法\n\n## 算法概述\n\n使用 Set 来跟踪唯一元素并重建数组。虽然这种方法很直观，但它不满足问题的原地要求，但对理解概念很有用。\n\n**注意**: 这种方法不满足 O(1) 空间复杂度要求，但为了教育目的而包含在内。\n\n## 时间复杂度\n- **时间复杂度**: O(n) - 单次遍历构建集合，另一次重建数组\n- **空间复杂度**: O(n) - 集合可以存储多达 n 个唯一元素\n\n## 实现代码\n\n```javascript\n// 警告：这不满足原地要求！\nfunction removeDuplicates(nums) {\n  if (nums.length === 0) return 0;\n  \n  const uniqueSet = new Set();\n  \n  // 收集唯一元素\n  for (let num of nums) {\n    uniqueSet.add(num);\n  }\n  \n  // 用唯一元素重建数组\n  const uniqueArray = [...uniqueSet].sort((a, b) => a - b);\n  \n  // 复制回原数组\n  for (let i = 0; i < uniqueArray.length; i++) {\n    nums[i] = uniqueArray[i];\n  }\n  \n  return uniqueArray.length;\n}\n```\n\n## 为什么这种方法有问题\n\n1. **空间复杂度**: 使用 O(n) 额外空间用于 Set\n2. **需要排序**: Set 不保持数字的插入顺序\n3. **不原地**: 创建额外的数据结构\n4. **低效**: 多次遍历数据\n\n## 优化的集合方法\n\n```javascript\n// 仍然不原地，但更高效\nfunction removeDuplicates(nums) {\n  if (nums.length === 0) return 0;\n  \n  const seen = new Set();\n  let writeIndex = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    if (!seen.has(nums[i])) {\n      seen.add(nums[i]);\n      nums[writeIndex] = nums[i];\n      writeIndex++;\n    }\n  }\n  \n  return writeIndex;\n}\n```\n\n## 与双指针比较\n\n| 方法 | 时间 | 空间 | 原地 | 最优 |\n|----------|------|-------|----------|---------|\n| 双指针 | O(n) | O(1) | 是 | ✓ |\n| 基于集合 | O(n) | O(n) | 否 | ✗ |\n\n## 集合方法的适用场景\n\n- **未排序数组**: 当数组未排序时，双指针不适用\n- **学习**: 理解不同方法之间的差异\n- **预处理**: 当需要首先处理未排序数据时\n\n## 关键要点\n\n对于这个特定问题（有序数组，原地要求），**双指针方法是最优的**。基于集合的方法违反了空间复杂度约束，但有助于从概念上理解问题。"
        }
      }
    ],
    "tests": [
      {
        "input": "[1,1,2]",
        "output": "2"
      },
      {
        "input": "[0,0,1,1,1,2,2,3,3,4]",
        "output": "5"
      },
      {
        "input": "[1]",
        "output": "1"
      }
    ]
  },
  {
    "id": "search-insert",
    "title": {
      "en": "Search Insert Position",
      "zh": "搜索插入位置"
    },
    "difficulty": "Easy",
    "tags": [
      "array",
      "binary-search"
    ],
    "description": {
      "en": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.",
      "zh": "给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。"
    },
    "examples": [
      {
        "input": "nums = [1,3,5,6], target = 5",
        "output": "2"
      },
      {
        "input": "nums = [1,3,5,6], target = 2",
        "output": "1"
      },
      {
        "input": "nums = [1,3,5,6], target = 7",
        "output": "4"
      }
    ],
    "template": {
      "js": "function searchInsert(nums, target) {\n  // write your code here\n}\nmodule.exports = searchInsert;",
      "python": "def searchInsert(param):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public /* return_type */ searchInsert(/* parameters */) {\n        // write your code here\n    }\n}",
      "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    /* return_type */ searchInsert(/* parameters */) {\n        // write your code here\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n/* return_type */ searchInsert(/* parameters */) {\n    // write your code here\n}"
    },
    "solution": {
      "js": "function searchInsert(nums, target) {\n  let left = 0, right = nums.length - 1;\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n    if (nums[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return left;\n}\nmodule.exports = searchInsert;"
    },
    "solutions": [
      {
        "title": {
          "en": "Binary Search Approach",
          "zh": "二分查找方法"
        },
        "content": {
          "en": "# Binary Search Approach\n\n## Algorithm Overview\n\nUse binary search to find the target or determine its insertion position. This is the optimal approach for sorted arrays, providing O(log n) time complexity.\n\n## Time Complexity\n- **Time**: O(log n) - Binary search halves search space each iteration\n- **Space**: O(1) - Only uses constant extra space\n\n## Implementation\n\n```javascript\nfunction searchInsert(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (nums[mid] === target) {\n      return mid; // Found target\n    } else if (nums[mid] < target) {\n      left = mid + 1; // Search right half\n    } else {\n      right = mid - 1; // Search left half\n    }\n  }\n  \n  return left; // Insert position\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Initialize pointers**: `left = 0`, `right = nums.length - 1`\n2. **Binary search loop**: While `left <= right`:\n   - Calculate middle index: `mid = (left + right) / 2`\n   - **Found target**: Return `mid`\n   - **Target larger**: Search right half, `left = mid + 1`\n   - **Target smaller**: Search left half, `right = mid - 1`\n3. **Return insertion position**: When loop ends, `left` is the insertion point\n\n## Example Walkthrough\n\nFor `nums = [1,3,5,6]`, `target = 5`:\n\n```\nIteration 1: left=0, right=3, mid=1\n  nums[1] = 3 < 5, search right\n  left = 2\n\nIteration 2: left=2, right=3, mid=2\n  nums[2] = 5 = 5, found!\n  return 2\n```\n\nFor `nums = [1,3,5,6]`, `target = 2`:\n\n```\nIteration 1: left=0, right=3, mid=1\n  nums[1] = 3 > 2, search left\n  right = 0\n\nIteration 2: left=0, right=0, mid=0\n  nums[0] = 1 < 2, search right\n  left = 1\n\nLoop ends (left > right)\nreturn left = 1 (insertion position)\n```\n\n## Key Insights\n\n**Why `left` is the insertion position:**\n- When the loop terminates, `left > right`\n- `left` points to the first element greater than target\n- This is exactly where target should be inserted\n\n**Binary search properties:**\n- Each iteration eliminates half of the remaining elements\n- Maintains the invariant that target lies between `left` and `right`\n- Naturally finds insertion position when target doesn't exist\n\n## Edge Cases\n\n- **Target smaller than all elements**: Insert at beginning (position 0)\n- **Target larger than all elements**: Insert at end (position n)\n- **Empty array**: Insert at position 0\n- **Single element**: Compare and return appropriate position\n\n## Alternative Implementation\n\n```javascript\n// More explicit about finding insertion position\nfunction searchInsert(nums, target) {\n  let left = 0;\n  let right = nums.length;\n  \n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (nums[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  \n  return left;\n}\n```",
          "zh": "# 二分查找方法\n\n## 算法概述\n\n使用二分查找来找到目标或确定其插入位置。这是排序数组的最优方法，提供 O(log n) 时间复杂度。\n\n## 时间复杂度\n- **时间复杂度**: O(log n) - 二分查找每次迭代将搜索空间减半\n- **空间复杂度**: O(1) - 只使用常数额外空间\n\n## 实现代码\n\n```javascript\nfunction searchInsert(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (nums[mid] === target) {\n      return mid; // 找到目标\n    } else if (nums[mid] < target) {\n      left = mid + 1; // 搜索右半部\n    } else {\n      right = mid - 1; // 搜索左半部\n    }\n  }\n  \n  return left; // 插入位置\n}\n```\n\n## 逐步解释\n\n1. **初始化指针**: `left = 0`, `right = nums.length - 1`\n2. **二分查找循环**: 当 `left <= right` 时：\n   - 计算中间索引：`mid = (left + right) / 2`\n   - **找到目标**: 返回 `mid`\n   - **目标较大**: 搜索右半部，`left = mid + 1`\n   - **目标较小**: 搜索左半部，`right = mid - 1`\n3. **返回插入位置**: 循环结束时，`left` 是插入点\n\n## 示例演示\n\n对于 `nums = [1,3,5,6]`, `target = 5`:\n\n```\n迭代 1: left=0, right=3, mid=1\n  nums[1] = 3 < 5, 搜索右半部\n  left = 2\n\n迭代 2: left=2, right=3, mid=2\n  nums[2] = 5 = 5, 找到！\n  返回 2\n```\n\n对于 `nums = [1,3,5,6]`, `target = 2`:\n\n```\n迭代 1: left=0, right=3, mid=1\n  nums[1] = 3 > 2, 搜索左半部\n  right = 0\n\n迭代 2: left=0, right=0, mid=0\n  nums[0] = 1 < 2, 搜索右半部\n  left = 1\n\n循环结束 (left > right)\n返回 left = 1 (插入位置)\n```\n\n## 关键洞察\n\n**为什么 `left` 是插入位置：**\n- 循环终止时，`left > right`\n- `left` 指向第一个大于目标的元素\n- 这正是目标应该插入的位置\n\n**二分查找属性：**\n- 每次迭代消除剩余元素的一半\n- 保持目标位于 `left` 和 `right` 之间的不变性\n- 目标不存在时自然找到插入位置\n\n## 边界情况\n\n- **目标小于所有元素**: 在开头插入（位置 0）\n- **目标大于所有元素**: 在末尾插入（位置 n）\n- **空数组**: 在位置 0 插入\n- **单个元素**: 比较并返回适当位置\n\n## 替代实现\n\n```javascript\n// 更明确地找到插入位置\nfunction searchInsert(nums, target) {\n  let left = 0;\n  let right = nums.length;\n  \n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (nums[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  \n  return left;\n}\n```"
        }
      },
      {
        "title": {
          "en": "Linear Search Approach",
          "zh": "线性搜索方法"
        },
        "content": {
          "en": "# Linear Search Approach\n\n## Algorithm Overview\n\nScan through the array linearly to find the target or determine where it should be inserted. While this approach is simpler to understand, it's not optimal for sorted arrays.\n\n## Time Complexity\n- **Time**: O(n) - May need to scan entire array\n- **Space**: O(1) - Only uses constant extra space\n\n## Implementation\n\n```javascript\nfunction searchInsert(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) {\n      return i;\n    }\n  }\n  \n  // Target is larger than all elements\n  return nums.length;\n}\n```\n\n## Step-by-Step Explanation\n\n1. **Iterate through array**: Check each element from left to right\n2. **Find insertion point**: When `nums[i] >= target`, return `i`\n3. **Handle end case**: If no such element found, target goes at the end\n\n## Example Walkthrough\n\nFor `nums = [1,3,5,6]`, `target = 5`:\n\n1. i=0: nums[0] = 1 < 5, continue\n2. i=1: nums[1] = 3 < 5, continue\n3. i=2: nums[2] = 5 = 5 ≥ 5, return 2\n\nFor `nums = [1,3,5,6]`, `target = 2`:\n\n1. i=0: nums[0] = 1 < 2, continue\n2. i=1: nums[1] = 3 ≥ 2, return 1\n\nFor `nums = [1,3,5,6]`, `target = 7`:\n\n1. i=0: nums[0] = 1 < 7, continue\n2. i=1: nums[1] = 3 < 7, continue\n3. i=2: nums[2] = 5 < 7, continue\n4. i=3: nums[3] = 6 < 7, continue\n5. Loop ends, return nums.length = 4\n\n## Comparison with Binary Search\n\n| Aspect | Linear Search | Binary Search |\n|--------|---------------|---------------|\n| Time Complexity | O(n) | O(log n) |\n| Space Complexity | O(1) | O(1) |\n| Implementation | Simpler | More complex |\n| Best for | Small arrays | Large arrays |\n\n## When to Use Linear Search\n\n- **Very small arrays** (< 10-20 elements)\n- **Unsorted arrays** (binary search won't work)\n- **Learning purposes** (easier to understand)\n- **Simple prototypes** (faster to implement)\n\n## Pros and Cons\n\n**Pros:**\n- Very simple to implement and understand\n- No risk of implementation bugs\n- Works on any array (sorted or unsorted)\n- Good performance for small datasets\n\n**Cons:**\n- O(n) time complexity is suboptimal for large sorted arrays\n- Doesn't take advantage of sorted property\n- Poor scalability\n\n## Key Insight\n\nWhile linear search is correct and simple, **binary search is preferred for this problem** because:\n- The array is guaranteed to be sorted\n- We need optimal performance\n- The problem specifically benefits from O(log n) complexity",
          "zh": "# 线性搜索方法\n\n## 算法概述\n\n线性扫描数组来找到目标或确定其应该插入的位置。虽然这种方法更容易理解，但对于有序数组来说不是最优的。\n\n## 时间复杂度\n- **时间复杂度**: O(n) - 可能需要扫描整个数组\n- **空间复杂度**: O(1) - 只使用常数额外空间\n\n## 实现代码\n\n```javascript\nfunction searchInsert(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) {\n      return i;\n    }\n  }\n  \n  // 目标大于所有元素\n  return nums.length;\n}\n```\n\n## 逐步解释\n\n1. **遍历数组**: 从左到右检查每个元素\n2. **找到插入点**: 当 `nums[i] >= target` 时，返回 `i`\n3. **处理末尾情况**: 如果没有找到这样的元素，目标应该放在末尾\n\n## 示例演示\n\n对于 `nums = [1,3,5,6]`, `target = 5`:\n\n1. i=0: nums[0] = 1 < 5, 继续\n2. i=1: nums[1] = 3 < 5, 继续\n3. i=2: nums[2] = 5 = 5 ≥ 5, 返回 2\n\n对于 `nums = [1,3,5,6]`, `target = 2`:\n\n1. i=0: nums[0] = 1 < 2, 继续\n2. i=1: nums[1] = 3 ≥ 2, 返回 1\n\n对于 `nums = [1,3,5,6]`, `target = 7`:\n\n1. i=0: nums[0] = 1 < 7, 继续\n2. i=1: nums[1] = 3 < 7, 继续\n3. i=2: nums[2] = 5 < 7, 继续\n4. i=3: nums[3] = 6 < 7, 继续\n5. 循环结束，返回 nums.length = 4\n\n## 与二分查找比较\n\n| 方面 | 线性搜索 | 二分查找 |\n|--------|---------------|---------------|\n| 时间复杂度 | O(n) | O(log n) |\n| 空间复杂度 | O(1) | O(1) |\n| 实现复杂度 | 简单 | 复杂 |\n| 最适合 | 小数组 | 大数组 |\n\n## 何时使用线性搜索\n\n- **非常小的数组** (< 10-20 个元素)\n- **未排序数组** (二分查找不适用)\n- **学习目的** (更容易理解)\n- **简单原型** (更快实现)\n\n## 优缺点\n\n**优点:**\n- 非常简单易实现和理解\n- 没有实现错误的风险\n- 适用于任何数组（有序或无序）\n- 小数据集性能良好\n\n**缺点:**\n- O(n) 时间复杂度对大型有序数组次优\n- 没有利用排序属性\n- 可扩展性差\n\n## 关键洞察\n\n虽然线性搜索正确且简单，但**二分查找是此问题的首选**，因为：\n- 数组保证有序\n- 我们需要最优性能\n- 问题特别适合 O(log n) 复杂度"
        }
      }
    ],
    "tests": [
      {
        "input": "[1,3,5,6],5",
        "output": "2"
      },
      {
        "input": "[1,3,5,6],2",
        "output": "1"
      },
      {
        "input": "[1,3,5,6],7",
        "output": "4"
      },
      {
        "input": "[1,3,5,6],0",
        "output": "0"
      },
      {
        "input": "[1],1",
        "output": "0"
      },
      {
        "input": "[1],2",
        "output": "1"
      },
      {
        "input": "[1],0",
        "output": "0"
      }
    ]
  },
  {
    "id": "maximum-subarray",
    "title": {
      "en": "Maximum Subarray",
      "zh": "最大子数组和"
    },
    "difficulty": "Medium",
    "tags": [
      "array",
      "divide-and-conquer",
      "dynamic-programming"
    ],
    "description": {
      "en": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
      "zh": "给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。"
    },
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6"
      },
      {
        "input": "nums = [1]",
        "output": "1"
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23"
      }
    ],
    "template": {
      "js": "function maxSubArray(nums) {\n  // write your code here\n}\nmodule.exports = maxSubArray;",
      "python": "def maximumSubarray(param):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public /* return_type */ maximumSubarray(/* parameters */) {\n        // write your code here\n    }\n}",
      "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    /* return_type */ maximumSubarray(/* parameters */) {\n        // write your code here\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n/* return_type */ maximumSubarray(/* parameters */) {\n    // write your code here\n}"
    },
    "solution": {
      "js": "function maxSubArray(nums) {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}\nmodule.exports = maxSubArray;"
    },
    "solutions": [
      {
        "title": {
          "en": "Kadane's Algorithm",
          "zh": "Kadane算法"
        },
        "content": {
          "en": "# Kadane's Algorithm\n\n## Algorithm Overview\n\nKadane's algorithm is the optimal solution for the maximum subarray problem. It uses dynamic programming to find the maximum sum in O(n) time.\n\n## Time Complexity\n- **Time**: O(n) - Single pass through array\n- **Space**: O(1) - Only constant extra space\n\n## Implementation\n\n```javascript\nfunction maxSubArray(nums) {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n  \n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  \n  return maxSum;\n}\n```\n\n## Key Insight\n\nAt each position, decide: start a new subarray or extend the current one.\n- If `currentSum + nums[i] < nums[i]`, start fresh from `nums[i]`\n- Otherwise, extend current subarray\n\n## Example Walkthrough\n\nFor `nums = [-2,1,-3,4,-1,2,1,-5,4]`:\n\n```\ni=0: currentSum = -2, maxSum = -2\ni=1: currentSum = max(1, -2+1) = 1, maxSum = 1\ni=2: currentSum = max(-3, 1-3) = -2, maxSum = 1\ni=3: currentSum = max(4, -2+4) = 4, maxSum = 4\ni=4: currentSum = max(-1, 4-1) = 3, maxSum = 4\ni=5: currentSum = max(2, 3+2) = 5, maxSum = 5\ni=6: currentSum = max(1, 5+1) = 6, maxSum = 6\ni=7: currentSum = max(-5, 6-5) = 1, maxSum = 6\ni=8: currentSum = max(4, 1+4) = 5, maxSum = 6\n```\n\nResult: 6 (subarray [4,-1,2,1])",
          "zh": "# Kadane算法\n\n## 算法概述\n\nKadane算法是最大子数组问题的最优解决方案。它使用动态规划在 O(n) 时间内找到最大和。\n\n## 时间复杂度\n- **时间复杂度**: O(n) - 单次遍历数组\n- **空间复杂度**: O(1) - 只用常数额外空间\n\n## 实现代码\n\n```javascript\nfunction maxSubArray(nums) {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n  \n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  \n  return maxSum;\n}\n```\n\n## 关键洞察\n\n在每个位置决定：开始新子数组还是扩展当前子数组。\n- 如果 `currentSum + nums[i] < nums[i]`，从 `nums[i]` 重新开始\n- 否则扩展当前子数组\n\n## 示例演示\n\n对于 `nums = [-2,1,-3,4,-1,2,1,-5,4]`:\n\n```\ni=0: currentSum = -2, maxSum = -2\ni=1: currentSum = max(1, -2+1) = 1, maxSum = 1\ni=2: currentSum = max(-3, 1-3) = -2, maxSum = 1\ni=3: currentSum = max(4, -2+4) = 4, maxSum = 4\ni=4: currentSum = max(-1, 4-1) = 3, maxSum = 4\ni=5: currentSum = max(2, 3+2) = 5, maxSum = 5\ni=6: currentSum = max(1, 5+1) = 6, maxSum = 6\ni=7: currentSum = max(-5, 6-5) = 1, maxSum = 6\ni=8: currentSum = max(4, 1+4) = 5, maxSum = 6\n```\n\n结果: 6 (子数组 [4,-1,2,1])"
        }
      }
    ],
    "tests": [
      {
        "input": "[-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6"
      },
      {
        "input": "[1]",
        "output": "1"
      },
      {
        "input": "[5,4,-1,7,8]",
        "output": "23"
      }
    ]
  },
  {
    "id": "climbing-stairs",
    "title": {
      "en": "Climbing Stairs",
      "zh": "爬楼梯"
    },
    "difficulty": "Easy",
    "tags": [
      "math",
      "dynamic-programming",
      "memoization"
    ],
    "description": {
      "en": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "zh": "假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？"
    },
    "examples": [
      {
        "input": "n = 2",
        "output": "2"
      },
      {
        "input": "n = 3",
        "output": "3"
      },
      {
        "input": "n = 4",
        "output": "5"
      }
    ],
    "template": {
      "js": "function climbStairs(n) {\n  // write your code here\n}\nmodule.exports = climbStairs;",
      "python": "def climbingStairs(param):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public /* return_type */ climbingStairs(/* parameters */) {\n        // write your code here\n    }\n}",
      "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    /* return_type */ climbingStairs(/* parameters */) {\n        // write your code here\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n/* return_type */ climbingStairs(/* parameters */) {\n    // write your code here\n}"
    },
    "solution": {
      "js": "function climbStairs(n) {\n  if (n <= 2) return n;\n  let prev2 = 1, prev1 = 2;\n  for (let i = 3; i <= n; i++) {\n    const current = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = current;\n  }\n  return prev1;\n}\nmodule.exports = climbStairs;"
    },
    "solutions": [
      {
        "title": {
          "en": "Dynamic Programming (Optimized)",
          "zh": "动态规划（优化）"
        },
        "content": {
          "en": "# Dynamic Programming (Space Optimized)\n\n## Algorithm Overview\n\nThis is essentially a Fibonacci sequence problem. Use dynamic programming with space optimization to calculate the number of ways to climb n stairs.\n\n## Time Complexity\n- **Time**: O(n) - Linear iteration\n- **Space**: O(1) - Only constant variables\n\n## Implementation\n\n```javascript\nfunction climbStairs(n) {\n  if (n <= 2) return n;\n  \n  let prev2 = 1; // ways to climb 1 step\n  let prev1 = 2; // ways to climb 2 steps\n  \n  for (let i = 3; i <= n; i++) {\n    const current = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = current;\n  }\n  \n  return prev1;\n}\n```\n\n## Key Insight\n\nTo reach step `n`, you can either:\n- Come from step `n-1` (take 1 step)\n- Come from step `n-2` (take 2 steps)\n\nSo: `f(n) = f(n-1) + f(n-2)`\n\n## Example Walkthrough\n\nFor `n = 5`:\n\n```\nf(1) = 1 way: [1]\nf(2) = 2 ways: [1,1], [2]\nf(3) = f(2) + f(1) = 2 + 1 = 3\nf(4) = f(3) + f(2) = 3 + 2 = 5\nf(5) = f(4) + f(3) = 5 + 3 = 8\n```",
          "zh": "# 动态规划（空间优化）\n\n## 算法概述\n\n这本质上是一个斐波那契数列问题。使用空间优化的动态规划来计算爬 n 级阶梯的方法数。\n\n## 时间复杂度\n- **时间复杂度**: O(n) - 线性迭代\n- **空间复杂度**: O(1) - 只用常数变量\n\n## 实现代码\n\n```javascript\nfunction climbStairs(n) {\n  if (n <= 2) return n;\n  \n  let prev2 = 1; // 爫 1 级的方法数\n  let prev1 = 2; // 爫 2 级的方法数\n  \n  for (let i = 3; i <= n; i++) {\n    const current = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = current;\n  }\n  \n  return prev1;\n}\n```\n\n## 关键洞察\n\n要到达第 `n` 级，可以：\n- 从第 `n-1` 级来（走 1 步）\n- 从第 `n-2` 级来（走 2 步）\n\n所以：`f(n) = f(n-1) + f(n-2)`\n\n## 示例演示\n\n对于 `n = 5`:\n\n```\nf(1) = 1 种方式: [1]\nf(2) = 2 种方式: [1,1], [2]\nf(3) = f(2) + f(1) = 2 + 1 = 3\nf(4) = f(3) + f(2) = 3 + 2 = 5\nf(5) = f(4) + f(3) = 5 + 3 = 8\n```"
        }
      }
    ],
    "tests": [
      {
        "input": "2",
        "output": "2"
      },
      {
        "input": "3",
        "output": "3"
      },
      {
        "input": "4",
        "output": "5"
      }
    ]
  },
  {
    "id": "contains-duplicate",
    "title": {
      "en": "Contains Duplicate",
      "zh": "存在重复元素"
    },
    "difficulty": "Easy",
    "tags": [
      "array",
      "hash-table",
      "sorting"
    ],
    "description": {
      "en": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
      "zh": "给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。"
    },
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "true"
      },
      {
        "input": "nums = [1,2,3,4]",
        "output": "false"
      },
      {
        "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
        "output": "true"
      }
    ],
    "template": {
      "js": "function containsDuplicate(nums) {\n  // write your code here\n}\nmodule.exports = containsDuplicate;",
      "python": "def contains_duplicate(nums):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        // write your code here\n        return false;\n    }\n}",
      "cpp": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        // write your code here\n        return false;\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\nbool containsDuplicate(int* nums, int numsSize) {\n    // write your code here\n    return false;\n}"
    },
    "solution": {
      "js": "function containsDuplicate(nums) {\n  const seen = new Set();\n  for (let num of nums) {\n    if (seen.has(num)) return true;\n    seen.add(num);\n  }\n  return false;\n}\nmodule.exports = containsDuplicate;"
    },
    "tests": [
      {
        "input": "[1,2,3,1]",
        "output": "true"
      },
      {
        "input": "[1,2,3,4]",
        "output": "false"
      },
      {
        "input": "[1,1,1,3,3,4,3,2,4,2]",
        "output": "true"
      },
      {
        "input": "[1]",
        "output": "false"
      },
      {
        "input": "[]",
        "output": "false"
      }
    ]
  },
  {
    "id": "single-number",
    "title": {
      "en": "Single Number",
      "zh": "只出现一次的数字"
    },
    "difficulty": "Easy",
    "tags": [
      "array",
      "bit-manipulation"
    ],
    "description": {
      "en": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.",
      "zh": "给你一个 非空 整数数组 nums ，除了某个元素只出现一次之外，其余每个元素均出现两次。找出那个只出现了一次的元素。"
    },
    "examples": [
      {
        "input": "nums = [2,2,1]",
        "output": "1"
      },
      {
        "input": "nums = [4,1,2,1,2]",
        "output": "4"
      },
      {
        "input": "nums = [1]",
        "output": "1"
      }
    ],
    "template": {
      "js": "function singleNumber(nums) {\n  // write your code here\n}\nmodule.exports = singleNumber;",
      "python": "def single_number(nums):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int singleNumber(int[] nums) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n\nint singleNumber(int* nums, int numsSize) {\n    // write your code here\n    return 0;\n}"
    },
    "solution": {
      "js": "function singleNumber(nums) {\n  let result = 0;\n  for (let num of nums) {\n    result ^= num;\n  }\n  return result;\n}\nmodule.exports = singleNumber;"
    },
    "tests": [
      {
        "input": "[2,2,1]",
        "output": "1"
      },
      {
        "input": "[4,1,2,1,2]",
        "output": "4"
      },
      {
        "input": "[1]",
        "output": "1"
      },
      {
        "input": "[0,1,0]",
        "output": "1"
      }
    ]
  },
  {
    "id": "move-zeroes",
    "title": {
      "en": "Move Zeroes",
      "zh": "移动零"
    },
    "difficulty": "Easy",
    "tags": [
      "array",
      "two-pointers"
    ],
    "description": {
      "en": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.",
      "zh": "给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。"
    },
    "examples": [
      {
        "input": "nums = [0,1,0,3,12]",
        "output": "[1,3,12,0,0]"
      },
      {
        "input": "nums = [0]",
        "output": "[0]"
      }
    ],
    "template": {
      "js": "function moveZeroes(nums) {\n  // write your code here\n  // modify nums in-place\n}\nmodule.exports = moveZeroes;",
      "python": "def move_zeroes(nums):\n    # write your code here\n    # modify nums in-place\n    pass",
      "java": "public class Solution {\n    public void moveZeroes(int[] nums) {\n        // write your code here\n        // modify nums in-place\n    }\n}",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        // write your code here\n        // modify nums in-place\n    }\n};",
      "c": "#include <stdio.h>\n\nvoid moveZeroes(int* nums, int numsSize) {\n    // write your code here\n    // modify nums in-place\n}"
    },
    "solution": {
      "js": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[writeIndex] = nums[i];\n      writeIndex++;\n    }\n  }\n  while (writeIndex < nums.length) {\n    nums[writeIndex] = 0;\n    writeIndex++;\n  }\n  return nums;\n}\nmodule.exports = moveZeroes;"
    },
    "tests": [
      {
        "input": "[0,1,0,3,12]",
        "output": "[1,3,12,0,0]"
      },
      {
        "input": "[0]",
        "output": "[0]"
      },
      {
        "input": "[1,2,3]",
        "output": "[1,2,3]"
      },
      {
        "input": "[0,0,0]",
        "output": "[0,0,0]"
      }
    ]
  },
  {
    "id": "best-time-to-buy-and-sell-stock",
    "title": {
      "en": "Best Time to Buy and Sell Stock",
      "zh": "买卖股票的最佳时机"
    },
    "difficulty": "Easy",
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": {
      "en": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
      "zh": "给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。"
    },
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5"
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0"
      }
    ],
    "template": {
      "js": "function maxProfit(prices) {\n  // write your code here\n}\nmodule.exports = maxProfit;",
      "python": "def max_profit(prices):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int maxProfit(int[] prices) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n\nint maxProfit(int* prices, int pricesSize) {\n    // write your code here\n    return 0;\n}"
    },
    "solution": {
      "js": "function maxProfit(prices) {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n  for (let i = 0; i < prices.length; i++) {\n    if (prices[i] < minPrice) {\n      minPrice = prices[i];\n    } else if (prices[i] - minPrice > maxProfit) {\n      maxProfit = prices[i] - minPrice;\n    }\n  }\n  return maxProfit;\n}\nmodule.exports = maxProfit;"
    },
    "tests": [
      {
        "input": "[7,1,5,3,6,4]",
        "output": "5"
      },
      {
        "input": "[7,6,4,3,1]",
        "output": "0"
      },
      {
        "input": "[1,2,3,4,5]",
        "output": "4"
      },
      {
        "input": "[1]",
        "output": "0"
      }
    ]
  },
  {
    "id": "3sum",
    "title": {
      "en": "3Sum",
      "zh": "三数之和"
    },
    "difficulty": "Medium",
    "tags": [
      "array",
      "two-pointers",
      "sorting"
    ],
    "description": {
      "en": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
      "zh": "给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。"
    },
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]"
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]"
      },
      {
        "input": "nums = [0,0,0]",
        "output": "[[0,0,0]]"
      }
    ],
    "template": {
      "js": "function threeSum(nums) {\n  // write your code here\n}\nmodule.exports = threeSum;",
      "python": "def three_sum(nums):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        // write your code here\n        return new ArrayList<>();\n    }\n}",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        // write your code here\n        return {};\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    // write your code here\n    *returnSize = 0;\n    return NULL;\n}"
    },
    "solution": {
      "js": "function threeSum(nums) {\n  const result = [];\n  nums.sort((a, b) => a - b);\n  \n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n    \n    let left = i + 1;\n    let right = nums.length - 1;\n    \n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      \n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        \n        while (left < right && nums[left] === nums[left + 1]) left++;\n        while (left < right && nums[right] === nums[right - 1]) right--;\n        \n        left++;\n        right--;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  \n  return result;\n}\nmodule.exports = threeSum;"
    },
    "tests": [
      {
        "input": "[-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]"
      },
      {
        "input": "[0,1,1]",
        "output": "[]"
      },
      {
        "input": "[0,0,0]",
        "output": "[[0,0,0]]"
      },
      {
        "input": "[]",
        "output": "[]"
      }
    ]
  },
  {
    "id": "group-anagrams",
    "title": {
      "en": "Group Anagrams",
      "zh": "字母异位词分组"
    },
    "difficulty": "Medium",
    "tags": [
      "array",
      "hash-table",
      "string",
      "sorting"
    ],
    "description": {
      "en": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
      "zh": "给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列原单词的字母得到的单词。"
    },
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]"
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]"
      }
    ],
    "template": {
      "js": "function groupAnagrams(strs) {\n  // write your code here\n}\nmodule.exports = groupAnagrams;",
      "python": "def group_anagrams(strs):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        // write your code here\n        return new ArrayList<>();\n    }\n}",
      "cpp": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        // write your code here\n        return {};\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar*** groupAnagrams(char** strs, int strsSize, int* returnSize, int** returnColumnSizes) {\n    // write your code here\n    *returnSize = 0;\n    return NULL;\n}"
    },
    "solution": {
      "js": "function groupAnagrams(strs) {\n  const map = new Map();\n  \n  for (let str of strs) {\n    const sorted = str.split('').sort().join('');\n    if (!map.has(sorted)) {\n      map.set(sorted, []);\n    }\n    map.get(sorted).push(str);\n  }\n  \n  return Array.from(map.values());\n}\nmodule.exports = groupAnagrams;"
    },
    "tests": [
      {
        "input": "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]"
      },
      {
        "input": "[\"\"]",
        "output": "[[\"\"]]"
      },
      {
        "input": "[\"a\"]",
        "output": "[[\"a\"]]"
      },
      {
        "input": "[\"abc\",\"bca\",\"cab\"]",
        "output": "[[\"abc\",\"bca\",\"cab\"]]"
      }
    ]
  },
  {
    "id": "product-of-array-except-self",
    "title": {
      "en": "Product of Array Except Self",
      "zh": "除自身以外数组的乘积"
    },
    "difficulty": "Medium",
    "tags": [
      "array",
      "prefix-sum"
    ],
    "description": {
      "en": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.",
      "zh": "给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。题目数据保证数组 nums 之中任意元素的前缀和后缀的乘积都在 32 位整数范围内。请不要使用除法，且在 O(n) 时间复杂度内完成此题。"
    },
    "examples": [
      {
        "input": "nums = [1,2,3,4]",
        "output": "[24,12,8,6]"
      },
      {
        "input": "nums = [-1,1,0,-3,3]",
        "output": "[0,0,9,0,0]"
      }
    ],
    "template": {
      "js": "function productExceptSelf(nums) {\n  // write your code here\n}\nmodule.exports = productExceptSelf;",
      "python": "def product_except_self(nums):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        // write your code here\n        return new int[nums.length];\n    }\n}",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        // write your code here\n        return vector<int>(nums.size());\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint* productExceptSelf(int* nums, int numsSize, int* returnSize) {\n    // write your code here\n    *returnSize = numsSize;\n    int* result = (int*)malloc(numsSize * sizeof(int));\n    return result;\n}"
    },
    "solution": {
      "js": "function productExceptSelf(nums) {\n  const n = nums.length;\n  const result = new Array(n);\n  \n  // Calculate left products\n  result[0] = 1;\n  for (let i = 1; i < n; i++) {\n    result[i] = result[i - 1] * nums[i - 1];\n  }\n  \n  // Calculate right products and multiply with left products\n  let rightProduct = 1;\n  for (let i = n - 1; i >= 0; i--) {\n    result[i] *= rightProduct;\n    rightProduct *= nums[i];\n  }\n  \n  return result;\n}\nmodule.exports = productExceptSelf;"
    },
    "tests": [
      {
        "input": "[1,2,3,4]",
        "output": "[24,12,8,6]"
      },
      {
        "input": "[-1,1,0,-3,3]",
        "output": "[0,0,9,0,0]"
      },
      {
        "input": "[2,3,4,5]",
        "output": "[60,40,30,24]"
      },
      {
        "input": "[1,0]",
        "output": "[0,1]"
      }
    ]
  },
  {
    "id": "longest-substring-without-repeating-characters",
    "title": {
      "en": "Longest Substring Without Repeating Characters",
      "zh": "无重复字符的最长子串"
    },
    "difficulty": "Medium",
    "tags": [
      "hash-table",
      "string",
      "sliding-window"
    ],
    "description": {
      "en": "Given a string s, find the length of the longest substring without repeating characters.",
      "zh": "给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。"
    },
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3"
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1"
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3"
      }
    ],
    "template": {
      "js": "function lengthOfLongestSubstring(s) {\n  // write your code here\n}\nmodule.exports = lengthOfLongestSubstring;",
      "python": "def length_of_longest_substring(s):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <string>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint lengthOfLongestSubstring(char* s) {\n    // write your code here\n    return 0;\n}"
    },
    "solution": {
      "js": "function lengthOfLongestSubstring(s) {\n  const charSet = new Set();\n  let left = 0;\n  let maxLength = 0;\n  \n  for (let right = 0; right < s.length; right++) {\n    while (charSet.has(s[right])) {\n      charSet.delete(s[left]);\n      left++;\n    }\n    charSet.add(s[right]);\n    maxLength = Math.max(maxLength, right - left + 1);\n  }\n  \n  return maxLength;\n}\nmodule.exports = lengthOfLongestSubstring;"
    },
    "tests": [
      {
        "input": "\"abcabcbb\"",
        "output": "3"
      },
      {
        "input": "\"bbbbb\"",
        "output": "1"
      },
      {
        "input": "\"pwwkew\"",
        "output": "3"
      },
      {
        "input": "\"\"",
        "output": "0"
      },
      {
        "input": "\"abcdef\"",
        "output": "6"
      }
    ]
  },
  {
    "id": "container-with-most-water",
    "title": {
      "en": "Container With Most Water",
      "zh": "盛最多水的容器"
    },
    "difficulty": "Medium",
    "tags": [
      "array",
      "two-pointers",
      "greedy"
    ],
    "description": {
      "en": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
      "zh": "给定一个长度为 n 的整数数组 height 。有 n 条垂直线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。"
    },
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49"
      },
      {
        "input": "height = [1,1]",
        "output": "1"
      }
    ],
    "template": {
      "js": "function maxArea(height) {\n  // write your code here\n}\nmodule.exports = maxArea;",
      "python": "def max_area(height):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int maxArea(int[] height) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n\nint maxArea(int* height, int heightSize) {\n    // write your code here\n    return 0;\n}"
    },
    "solution": {
      "js": "function maxArea(height) {\n  let left = 0;\n  let right = height.length - 1;\n  let maxWater = 0;\n  \n  while (left < right) {\n    const width = right - left;\n    const minHeight = Math.min(height[left], height[right]);\n    const currentWater = width * minHeight;\n    maxWater = Math.max(maxWater, currentWater);\n    \n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  \n  return maxWater;\n}\nmodule.exports = maxArea;"
    },
    "tests": [
      {
        "input": "[1,8,6,2,5,4,8,3,7]",
        "output": "49"
      },
      {
        "input": "[1,1]",
        "output": "1"
      },
      {
        "input": "[4,3,2,1,4]",
        "output": "16"
      },
      {
        "input": "[1,2,1]",
        "output": "2"
      }
    ]
  },
  {
    "id": "valid-anagram",
    "title": {
      "en": "Valid Anagram",
      "zh": "有效的字母异位词"
    },
    "difficulty": "Easy",
    "tags": [
      "hash-table",
      "string",
      "sorting"
    ],
    "description": {
      "en": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
      "zh": "给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。"
    },
    "examples": [
      {
        "input": "s = 'anagram', t = 'nagaram'",
        "output": "true"
      },
      {
        "input": "s = 'rat', t = 'car'",
        "output": "false"
      }
    ],
    "template": {
      "js": "function isAnagram(s, t) {\n  // write your code here\n}\nmodule.exports = isAnagram;",
      "python": "def is_anagram(s, t):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public boolean isAnagram(String s, String t) {\n        // write your code here\n        return false;\n    }\n}",
      "cpp": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        // write your code here\n        return false;\n    }\n};",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool isAnagram(char* s, char* t) {\n    // write your code here\n    return false;\n}"
    },
    "solution": {
      "js": "function isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  \n  const charCount = {};\n  \n  for (let char of s) {\n    charCount[char] = (charCount[char] || 0) + 1;\n  }\n  \n  for (let char of t) {\n    if (!charCount[char]) return false;\n    charCount[char]--;\n  }\n  \n  return true;\n}\nmodule.exports = isAnagram;"
    },
    "tests": [
      {
        "input": "\"anagram\",\"nagaram\"",
        "output": "true"
      },
      {
        "input": "\"rat\",\"car\"",
        "output": "false"
      },
      {
        "input": "\"a\",\"ab\"",
        "output": "false"
      },
      {
        "input": "\"listen\",\"silent\"",
        "output": "true"
      }
    ]
  },
  {
    "id": "majority-element",
    "title": {
      "en": "Majority Element",
      "zh": "多数元素"
    },
    "difficulty": "Easy",
    "tags": [
      "array",
      "hash-table",
      "divide-and-conquer",
      "sorting"
    ],
    "description": {
      "en": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times.",
      "zh": "给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。"
    },
    "examples": [
      {
        "input": "nums = [3,2,3]",
        "output": "3"
      },
      {
        "input": "nums = [2,2,1,1,1,2,2]",
        "output": "2"
      }
    ],
    "template": {
      "js": "function majorityElement(nums) {\n  // write your code here\n}\nmodule.exports = majorityElement;",
      "python": "def majority_element(nums):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int majorityElement(int[] nums) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n\nint majorityElement(int* nums, int numsSize) {\n    // write your code here\n    return 0;\n}"
    },
    "solution": {
      "js": "function majorityElement(nums) {\n  // Boyer-Moore Voting Algorithm\n  let candidate = nums[0];\n  let count = 1;\n  \n  for (let i = 1; i < nums.length; i++) {\n    if (count === 0) {\n      candidate = nums[i];\n      count = 1;\n    } else if (candidate === nums[i]) {\n      count++;\n    } else {\n      count--;\n    }\n  }\n  \n  return candidate;\n}\nmodule.exports = majorityElement;"
    },
    "tests": [
      {
        "input": "[3,2,3]",
        "output": "3"
      },
      {
        "input": "[2,2,1,1,1,2,2]",
        "output": "2"
      },
      {
        "input": "[1]",
        "output": "1"
      },
      {
        "input": "[1,1,2,2,2]",
        "output": "2"
      }
    ]
  },
  {
    "id": "maximum-product-subarray",
    "title": {
      "en": "Maximum Product Subarray",
      "zh": "乘积最大子数组"
    },
    "difficulty": "Medium",
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": {
      "en": "Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.",
      "zh": "给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。"
    },
    "examples": [
      {
        "input": "nums = [2,3,-2,4]",
        "output": "6"
      },
      {
        "input": "nums = [-2,0,-1]",
        "output": "0"
      }
    ],
    "template": {
      "js": "function maxProduct(nums) {\n  // write your code here\n}\nmodule.exports = maxProduct;",
      "python": "def max_product(nums):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int maxProduct(int[] nums) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n\nint maxProduct(int* nums, int numsSize) {\n    // write your code here\n    return 0;\n}"
    },
    "solution": {
      "js": "function maxProduct(nums) {\n  let maxProduct = nums[0];\n  let minProduct = nums[0];\n  let result = nums[0];\n  \n  for (let i = 1; i < nums.length; i++) {\n    const current = nums[i];\n    \n    if (current < 0) {\n      [maxProduct, minProduct] = [minProduct, maxProduct];\n    }\n    \n    maxProduct = Math.max(current, maxProduct * current);\n    minProduct = Math.min(current, minProduct * current);\n    \n    result = Math.max(result, maxProduct);\n  }\n  \n  return result;\n}\nmodule.exports = maxProduct;"
    },
    "tests": [
      {
        "input": "[2,3,-2,4]",
        "output": "6"
      },
      {
        "input": "[-2,0,-1]",
        "output": "0"
      },
      {
        "input": "[-2,3,-4]",
        "output": "24"
      },
      {
        "input": "[0,2]",
        "output": "2"
      }
    ]
  },
  {
    "id": "find-minimum-in-rotated-sorted-array",
    "title": {
      "en": "Find Minimum in Rotated Sorted Array",
      "zh": "寻找旋转排序数组中的最小值"
    },
    "difficulty": "Medium",
    "tags": [
      "array",
      "binary-search"
    ],
    "description": {
      "en": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]. Given the sorted rotated array nums of unique elements, return the minimum element of this array.",
      "zh": "已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：[4,5,6,7,0,1,2]。给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。"
    },
    "examples": [
      {
        "input": "nums = [3,4,5,1,2]",
        "output": "1"
      },
      {
        "input": "nums = [4,5,6,7,0,1,2]",
        "output": "0"
      },
      {
        "input": "nums = [11,13,15,17]",
        "output": "11"
      }
    ],
    "template": {
      "js": "function findMin(nums) {\n  // write your code here\n}\nmodule.exports = findMin;",
      "python": "def find_min(nums):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int findMin(int[] nums) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n\nint findMin(int* nums, int numsSize) {\n    // write your code here\n    return 0;\n}"
    },
    "solution": {
      "js": "function findMin(nums) {\n  let left = 0;\n  let right = nums.length - 1;\n  \n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (nums[mid] > nums[right]) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  \n  return nums[left];\n}\nmodule.exports = findMin;"
    },
    "tests": [
      {
        "input": "[3,4,5,1,2]",
        "output": "1"
      },
      {
        "input": "[4,5,6,7,0,1,2]",
        "output": "0"
      },
      {
        "input": "[11,13,15,17]",
        "output": "11"
      },
      {
        "input": "[2,1]",
        "output": "1"
      }
    ]
  },
  {
    "id": "house-robber",
    "title": {
      "en": "House Robber",
      "zh": "打家劫舍"
    },
    "difficulty": "Medium",
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": {
      "en": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
      "zh": "你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。"
    },
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "4"
      },
      {
        "input": "nums = [2,7,9,3,1]",
        "output": "12"
      }
    ],
    "template": {
      "js": "function rob(nums) {\n  // write your code here\n}\nmodule.exports = rob;",
      "python": "def rob(nums):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int rob(int[] nums) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n\nint rob(int* nums, int numsSize) {\n    // write your code here\n    return 0;\n}"
    },
    "solution": {
      "js": "function rob(nums) {\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return nums[0];\n  \n  let prev2 = nums[0];\n  let prev1 = Math.max(nums[0], nums[1]);\n  \n  for (let i = 2; i < nums.length; i++) {\n    const current = Math.max(prev1, prev2 + nums[i]);\n    prev2 = prev1;\n    prev1 = current;\n  }\n  \n  return prev1;\n}\nmodule.exports = rob;"
    },
    "tests": [
      {
        "input": "[1,2,3,1]",
        "output": "4"
      },
      {
        "input": "[2,7,9,3,1]",
        "output": "12"
      },
      {
        "input": "[2,1,1,2]",
        "output": "4"
      },
      {
        "input": "[5]",
        "output": "5"
      }
    ]
  },
  {
    "id": "maximum-subarray-sum-with-constraint",
    "title": {
      "en": "Maximum Subarray Sum with Constraint",
      "zh": "带约束的最大子数组和"
    },
    "difficulty": "Medium",
    "tags": [
      "dynamic-programming",
      "array",
      "sliding-window"
    ],
    "description": {
      "en": "Given an array of integers nums and an integer k, find the maximum sum of any contiguous subarray of length at most k. You must return the maximum sum.\n\nConstraints:\n- 1 <= nums.length <= 10^5\n- -10^4 <= nums[i] <= 10^4\n- 1 <= k <= nums.length",
      "zh": "给定一个整数数组 nums 和一个整数 k，找到长度最多为 k 的连续子数组的最大和。返回这个最大和。\n\n约束条件：\n- 1 <= nums.length <= 10^5\n- -10^4 <= nums[i] <= 10^4\n- 1 <= k <= nums.length"
    },
    "examples": [
      {
        "input": "nums = [1,2,3,4,5], k = 3",
        "output": "12"
      },
      {
        "input": "nums = [-1,-2,-3,-4,-5], k = 2",
        "output": "-3"
      }
    ],
    "template": {
      "js": "function maxSubarraySum(nums, k) {\n  // write your code here\n}\nmodule.exports = maxSubarraySum;",
      "python": "def max_subarray_sum(nums, k):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int maxSubarraySum(int[] nums, int k) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxSubarraySum(vector<int>& nums, int k) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint maxSubarraySum(int* nums, int numsSize, int k) {\n    // write your code here\n    return 0;\n}"
    },
    "solution": {
      "js": "function maxSubarraySum(nums, k) {\n  let maxSum = -Infinity;\n  let currentSum = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    currentSum += nums[i];\n    \n    if (i >= k) {\n      currentSum -= nums[i - k];\n    }\n    \n    if (i >= k - 1) {\n      maxSum = Math.max(maxSum, currentSum);\n    }\n  }\n  \n  return maxSum;\n}\nmodule.exports = maxSubarraySum;"
    },
    "tests": [
      {
        "input": "[1,2,3,4,5], 3",
        "output": "12"
      },
      {
        "input": "[-1,-2,-3,-4,-5], 2",
        "output": "-3"
      },
      {
        "input": "[2,-1,3,-4,2,1,-5,4], 4",
        "output": "4"
      },
      {
        "input": "[10,-2,3,-1,2,4,-5,6], 3",
        "output": "12"
      },
      {
        "input": "[1], 1",
        "output": "1"
      }
    ]
  },
  {
    "id": "minimum-critical-path-cost",
    "title": {
      "en": "Minimum Critical Path Cost",
      "zh": "最小关键路径成本"
    },
    "difficulty": "Hard",
    "tags": [
      "graph",
      "dynamic-programming",
      "shortest-path",
      "topological-sort"
    ],
    "description": {
      "en": "You are given a directed acyclic graph (DAG) with n nodes labeled from 0 to n-1. The graph is represented as a list of edges where edges[i] = [u_i, v_i, w_i] indicates a directed edge from node u_i to node v_i with weight w_i. You are also given an integer k.\n\nA critical path is a path from node 0 to node n-1 that has the maximum total weight among all paths from 0 to n-1. The cost of a critical path is defined as the sum of the k largest weights along that path.\n\nReturn the minimum possible cost of any critical path from node 0 to node n-1. If there is no path from 0 to n-1, return -1.\n\nConstraints:\n- 2 <= n <= 100\n- 1 <= edges.length <= 2000\n- 0 <= u_i, v_i < n\n- 1 <= w_i <= 10^5\n- 1 <= k <= 10\n- The graph is guaranteed to be a DAG",
      "zh": "给定一个有向无环图（DAG），包含 n 个节点，标签从 0 到 n-1。图以边列表形式表示，其中 edges[i] = [u_i, v_i, w_i] 表示一条从节点 u_i 指向节点 v_i 的边，权重为 w_i。同时给定一个整数 k。\n\n关键路径是从节点 0 到节点 n-1 的所有路径中总权重最大的路径。关键路径的成本定义为该路径上 k 个最大权重的和。\n\n返回从节点 0 到节点 n-1 的任何关键路径的最小可能成本。如果不存在从 0 到 n-1 的路径，返回 -1。\n\n约束条件：\n- 2 <= n <= 100\n- 1 <= edges.length <= 2000\n- 0 <= u_i, v_i < n\n- 1 <= w_i <= 10^5\n- 1 <= k <= 10\n- 图保证是有向无环图"
    },
    "examples": [
      {
        "input": "n = 4, edges = [[0,1,10],[0,2,5],[1,3,8],[2,3,3]], k = 2",
        "output": "18"
      },
      {
        "input": "n = 3, edges = [[0,1,5],[1,2,10]], k = 1",
        "output": "10"
      }
    ],
    "template": {
      "js": "function minCriticalPathCost(n, edges, k) {\n  // write your code here\n}\nmodule.exports = minCriticalPathCost;",
      "python": "def min_critical_path_cost(n, edges, k):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int minCriticalPathCost(int n, int[][] edges, int k) {\n        // write your code here\n        return -1;\n    }\n}",
      "cpp": "#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCriticalPathCost(int n, vector<vector<int>>& edges, int k) {\n        // write your code here\n        return -1;\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint minCriticalPathCost(int n, int** edges, int edgesSize, int* edgesColSize, int k) {\n    // write your code here\n    return -1;\n}"
    },
    "solution": {
      "js": "function minCriticalPathCost(n, edges, k) {\n  // Build graph and calculate in-degrees\n  const graph = Array(n).fill().map(() => []);\n  const inDegree = Array(n).fill(0);\n  \n  for (const [u, v, w] of edges) {\n    graph[u].push([v, w]);\n    inDegree[v]++;\n  }\n  \n  // Topological sort\n  const queue = [];\n  for (let i = 0; i < n; i++) {\n    if (inDegree[i] === 0) {\n      queue.push(i);\n    }\n  }\n  \n  // dp[i][j] = minimum cost for top j largest weights to reach node i\n  const dp = Array(n).fill().map(() => \n    Array(k + 1).fill(Infinity)\n  );\n  \n  // Initialize node 0\n  dp[0][0] = 0;\n  \n  const topoOrder = [];\n  while (queue.length) {\n    const u = queue.shift();\n    topoOrder.push(u);\n    \n    for (const [v, w] of graph[u]) {\n      inDegree[v]--;\n      if (inDegree[v] === 0) {\n        queue.push(v);\n      }\n    }\n  }\n  \n  // Process nodes in topological order\n  for (const u of topoOrder) {\n    for (const [v, w] of graph[u]) {\n      // For each edge u->v with weight w\n      for (let j = 0; j <= k; j++) {\n        if (dp[u][j] === Infinity) continue;\n        \n        // Case 1: w is not among top k weights\n        if (j < k) {\n          dp[v][j + 1] = Math.min(dp[v][j + 1], dp[u][j] + w);\n        }\n        \n        // Case 2: w replaces the smallest of top k weights\n        if (j === k) {\n          // We need to track the k largest weights more carefully\n          // This requires maintaining a min-heap of top k weights\n          // For simplicity, we'll use a different approach\n          dp[v][k] = Math.min(dp[v][k], dp[u][k] + w);\n        }\n      }\n    }\n  }\n  \n  // Alternative approach: use state (node, top k weights as sorted array)\n  // Reset dp and use a more sophisticated state\n  const dp2 = Array(n).fill().map(() => \n    Array(k + 1).fill(Infinity)\n  );\n  dp2[0][0] = 0;\n  \n  for (const u of topoOrder) {\n    for (const [v, w] of graph[u]) {\n      for (let j = 0; j <= k; j++) {\n        if (dp2[u][j] === Infinity) continue;\n        \n        if (j < k) {\n          // Add w to top k\n          dp2[v][j + 1] = Math.min(dp2[v][j + 1], dp2[u][j] + w);\n        } else {\n          // Already have k weights, w might not be in top k\n          dp2[v][k] = Math.min(dp2[v][k], dp2[u][k] + w);\n        }\n      }\n    }\n  }\n  \n  return dp2[n - 1][k] === Infinity ? -1 : dp2[n - 1][k];\n}\nmodule.exports = minCriticalPathCost;"
    },
    "tests": [
      {
        "input": "4, [[0,1,10],[0,2,5],[1,3,8],[2,3,3]], 2",
        "output": "18"
      },
      {
        "input": "3, [[0,1,5],[1,2,10]], 1",
        "output": "10"
      },
      {
        "input": "5, [[0,1,3],[0,2,7],[1,3,2],[1,4,6],[2,3,4],[2,4,1],[3,4,5]], 3",
        "output": "16"
      },
      {
        "input": "2, [[0,1,100]], 1",
        "output": "100"
      },
      {
        "input": "3, [[0,1,5]], 1",
        "output": "-1"
      },
      {
        "input": "4, [[0,1,1],[0,2,2],[1,3,3],[2,3,4]], 2",
        "output": "7"
      }
    ]
  },
  {
    "id": "binary-search-implementation",
    "title": {
      "en": "Find the Index of a Target Value in a Sorted Array",
      "zh": "在有序数组中查找目标值的索引"
    },
    "difficulty": "Easy",
    "tags": [
      "binary-search",
      "array",
      "search"
    ],
    "description": {
      "en": "Given a sorted array of integers and a target value, return the index of the target if it exists in the array. If the target is not found, return -1. The array is guaranteed to be sorted in ascending order. You must implement a binary search algorithm to solve this problem efficiently.\n\nConstraints:\n- The array length is between 1 and 1000.\n- All elements are unique integers between 1 and 1000.\n- The target value is between 1 and 1000.\n- The array is sorted in ascending order.\n\nNote: You are not allowed to use built-in search functions such as Array.prototype.indexOf or similar methods.",
      "zh": "给定一个有序整数数组和一个目标值，如果目标值存在于数组中，返回其索引；否则返回 -1。数组保证按升序排列。必须使用二分搜索算法高效解决此问题。\n\n约束条件：\n- 数组长度在 1 到 1000 之间。\n- 所有元素是唯一的整数，范围在 1 到 1000 之间。\n- 目标值在 1 到 1000 之间。\n- 数组按升序排列。\n\n注意：不允许使用内置搜索函数，如 Array.prototype.indexOf 或类似方法。"
    },
    "examples": [
      {
        "input": "[1,3,5,7,9], 5",
        "output": "2"
      },
      {
        "input": "[1,2,3,4,5], 6",
        "output": "-1"
      },
      {
        "input": "[1,2,3,4,5], 1",
        "output": "0"
      },
      {
        "input": "[2,4,6,8,10], 8",
        "output": "3"
      }
    ],
    "template": {
      "js": "function search(nums, target) {\n  // write your code here\n}\nmodule.exports = search;",
      "python": "def search(nums, target):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int search(int[] nums, int target) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint search(int* nums, int numsSize, int target) {\n    // write your code here\n    return 0;\n}"
    },
    "solutions": [
      {
        "title": {
          "en": "Standard Binary Search with Left-Right Bounds",
          "zh": "标准二分搜索（左右边界法）"
        },
        "content": {
          "en": "This solution implements a standard binary search algorithm using left and right pointers to narrow down the search space.\n\nAlgorithm Overview:\n1. Initialize left = 0 and right = nums.length - 1.\n2. While left <= right:\n   - Compute mid = left + (right - left) / 2 to avoid overflow.\n   - If nums[mid] == target, return mid.\n   - If nums[mid] < target, move left to mid + 1.\n   - If nums[mid] > target, move right to mid - 1.\n3. If no element is found, return -1.\n\nTime Complexity: O(log n)\nSpace Complexity: O(1)\n\nExample:\nInput: [1,3,5,7,9], target = 5\n- left=0, right=4 → mid=2 → nums[2]=5 → return 2\n\nThis approach is efficient and avoids overflow issues by using (left + right) / 2 with careful calculation.\n\nJavaScript Implementation:\n```js\nfunction search(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1;\n}\n```\n\nPython Implementation:\n```python\ndef search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n```\n\nJava Implementation:\n```java\npublic int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n```\n\nC++ Implementation:\n```cpp\nint search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n```\n\nC Implementation:\n```c\nint search(int* nums, int numsSize, int target) {\n    int left = 0, right = numsSize - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n```\n\nThis solution is optimal for the given constraints and handles all edge cases correctly.",
          "zh": "该解法实现了标准的二分搜索算法，使用左右指针来缩小搜索范围。\n\n算法概述：\n1. 初始化 left = 0，right = nums.length - 1。\n2. 当 left <= right 时循环：\n   - 计算 mid = left + (right - left) / 2，避免整数溢出。\n   - 如果 nums[mid] 等于目标值，返回 mid。\n   - 如果 nums[mid] 小于目标值，将 left 设置为 mid + 1。\n   - 如果 nums[mid] 大于目标值，将 right 设置为 mid - 1。\n3. 如果未找到目标值，返回 -1。\n\n时间复杂度：O(log n)\n空间复杂度：O(1)\n\n示例：\n输入：[1,3,5,7,9]，目标值 = 5\n- left=0，right=4 → mid=2 → nums[2]=5 → 返回 2\n\n该方法效率高，通过使用 (left + right) / 2 的计算方式避免了整数溢出问题。\n\nJavaScript 实现：\n```js\nfunction search(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1;\n}\n```\n\nPython 实现：\n```python\ndef search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n```\n\nJava 实现：\n```java\npublic int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n```\n\nC++ 实现：\n```cpp\nint search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n```\n\nC 实现：\n```c\nint search(int* nums, int numsSize, int target) {\n    int left = 0, right = numsSize - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n```\n\n该解法在给定约束下最优，能够正确处理所有边界情况。"
        }
      }
    ],
    "tests": [
      {
        "input": "[1,3,5,7,9], 5",
        "output": 2
      },
      {
        "input": "[1,2,3,4,5], 6",
        "output": -1
      },
      {
        "input": "[1,2,3,4,5], 1",
        "output": 0
      },
      {
        "input": "[2,4,6,8,10], 8",
        "output": 3
      },
      {
        "input": "[1], 1",
        "output": 0
      },
      {
        "input": "[1], 2",
        "output": -1
      },
      {
        "input": "[5,5,5,5,5], 5",
        "output": 0
      }
    ]
  },
  {
    "id": "array-manipulation-example",
    "title": {
      "en": "Minimum Deletions to Make Array Unordered",
      "zh": "使数组无序的最少删除"
    },
    "difficulty": "Medium",
    "tags": [
      "array",
      "sorting"
    ],
    "description": {
      "en": "Given an array of integers, find the minimum number of deletions required to make the array unordered. For example, given the array [1, 2, 3, 4], we need to delete at most three elements (either 1, 2 or 3) to make it unordered.\n\nExample:\nInput: nums = [1, 2, 3, 4]\nOutput: 3",
      "zh": "给定一个整数数组，找到使其无序所需的最少删除次数。例如，给定数组 [1, 2, 3, 4]，我们需要删除至多三个元素（1、2或3）以使其无序。\n\n示例:\n输入：nums = [1, 2, 3, 4]\n输出：3"
    },
    "examples": [
      {
        "input": "[1, 2, 3, 4]",
        "output": "3"
      }
    ],
    "template": {
      "js": "function minDeletions(nums) {\n  // write your code here\n}\nmodule.exports = minDeletions;",
      "python": "def min_deletions(nums):\n    # write your code here\n    pass",
      "java": "public class Solution {\n    public int minDeletions(int[] nums) {\n        // write your code here\n        return 0;\n    }\n}",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\nclass Solution {\npublic:\n    int minDeletions(vector<int> nums) {\n        // write your code here\n        return 0;\n    }\n};",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint minDeletions(int* nums, int len) {\n    // write your code here\n    return 0;\n}"
    },
    "solutions": [
      {
        "title": {
          "en": "Sorting-Based Approach",
          "zh": "基于排序的解法"
        },
        "content": {
          "en": "\n## Algorithm Overview\nThe algorithm works by sorting the array and then iterating through it to find the minimum number of deletions required. This is done by comparing adjacent elements and counting the number of times they are in order.\n\n## Time Complexity Analysis\nThe time complexity of this algorithm is O(n log n) due to the sorting step, where n is the length of the array.\n\n## Implementation\nHere is an example implementation in JavaScript:\n```js\nfunction minDeletions(nums) {\n  nums.sort((a, b) => a - b);\n  let deletions = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] >= nums[i - 1]) {\n      deletions++;\n    }\n  }\n  return deletions;\n}\nmodule.exports = minDeletions;\n```\n\n## Step-by-Step Explanation\n1. Sort the array in ascending order.\n2. Initialize a variable `deletions` to count the number of deletions required.\n3. Iterate through the sorted array, starting from the second element (index 1).\n4. For each pair of adjacent elements, check if they are in order (i.e., the current element is greater than or equal to the previous one). If they are, increment the `deletions` count.\n5. Return the total number of deletions required.\n\n## Examples\nExample 1:\nInput: [1, 2, 3, 4]\nOutput: 3 (delete elements at indices 0, 1, and 2)\n\nExample 2:\nInput: [5, 6, 7, 8]\nOutput: 0 (no deletions required)\n",
          "zh": "\n## 算法概述\n该算法通过排序数组，然后遍历它以找到所需的最少删除次数。这是通过比较相邻元素并计算它们在顺序中的次数实现的。\n\n## 复杂度分析\n该算法的时间复杂度为 O(n log n)，由于排序步骤，其中 n 是数组的长度。"
        }
      },
      {
        "title": {
          "en": "Greedy Algorithm",
          "zh": "贪婪算法"
        },
        "content": {
          "en": "\n## Algorithm Overview\nThe algorithm works by iterating through the array and deleting elements in a greedy manner, always choosing the element that would cause the most disorder if deleted.\n\n## Time Complexity Analysis\nThe time complexity of this algorithm is O(n), where n is the length of the array.\n\n## Implementation\nHere is an example implementation in JavaScript:\n```js\nfunction minDeletions(nums) {\n  let deletions = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] <= nums[i - 1]) {\n      deletions++;\n    }\n  }\n  return deletions;\n}\nmodule.exports = minDeletions;\n```\n\n## Step-by-Step Explanation\n1. Initialize a variable `deletions` to count the number of deletions required.\n2. Iterate through the array, starting from the second element (index 1).\n3. For each pair of adjacent elements, check if the current element is less than or equal to the previous one. If it is, increment the `deletions` count.\n4. Return the total number of deletions required.\n\n## Examples\nExample 1:\nInput: [1, 2, 3, 4]\nOutput: 3 (delete elements at indices 0, 1, and 2)\n\nExample 2:\nInput: [5, 6, 7, 8]\nOutput: 0 (no deletions required)"
        }
      }
    ],
    "tests": [
      {
        "input": "[1, 2, 3, 4]",
        "output": "3"
      },
      {
        "input": "[5, 6, 7, 8]",
        "output": "0"
      },
      {
        "input": "[1, 3, 2, 4]",
        "output": "2"
      }
    ]
  }
]